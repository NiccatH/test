(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

var _iosVhFix = require("./utils/ios-vh-fix");
var _initModals = require("./modules/modals/init-modals");
var _index = require("./modules/header/index.js");
var _loader = require("./modules/loader");
var _initSplitter = require("./modules/init-splitter");
var _animations = require("./modules/animations");
var _initMoveTo = require("./modules/init-move-to");
var _initMaps = require("./modules/maps/init-maps.js");
// ---------------------------------

window.addEventListener('DOMContentLoaded', function () {
  // Utils
  // --------------------------------
  (0, _iosVhFix.iosVhFix)();
  (0, _index.initHeaderModules)();
  var loader = new _loader.Loader();

  // Modules
  // ---------------------------------

  // все скрипты должны быть в обработчике 'DOMContentLoaded', но не все в 'load'
  // в load следует добавить скрипты, не участвующие в работе первого экрана
  window.addEventListener('load', function () {
    (0, _initModals.initModals)();
    (0, _initSplitter.initSplitter)();
    (0, _initMoveTo.initScrollTo)();
    (0, _initMaps.initMaps)();
  });
  window.addEventListener('loaderOff', function () {
    (0, _animations.initAnimationModule)();
  });
});

// ---------------------------------

// ❗❗❗ обязательно установите плагины eslint, stylelint, editorconfig в редактор кода.

// привязывайте js не на классы, а на дата атрибуты (data-validate)

// вместо модификаторов .block--active используем утилитарные классы
// .is-active || .is-open || .is-invalid и прочие (обязателен нейминг в два слова)
// .select.select--opened ❌ ---> [data-select].is-open ✅

// выносим все в дата атрибуты
// url до иконок пинов карты, настройки автопрокрутки слайдера, url к json и т.д.

// для адаптивного JS используейтся matchMedia и addListener
// const breakpoint = window.matchMedia(`(min-width:1024px)`);
// const breakpointChecker = () => {
//   if (breakpoint.matches) {
//   } else {
//   }
// };
// breakpoint.addListener(breakpointChecker);
// breakpointChecker();

// используйте .closest(el)

},{"./modules/animations":4,"./modules/header/index.js":7,"./modules/init-move-to":10,"./modules/init-splitter":11,"./modules/loader":12,"./modules/maps/init-maps.js":18,"./modules/modals/init-modals":23,"./utils/ios-vh-fix":28}],2:[function(require,module,exports){
"use strict";

var _scrollTrigger = require("../../vendor/scroll-trigger.js");
var _pageScroller = require("../../utils/page-scroller.js");
// const fadeElements = document.querySelectorAll('[data-animate="fade"] [data-animate-item]');
// gsap.set(fadeElements, {autoAlpha: 0});
_scrollTrigger.ScrollTrigger.batch('[data-animate="fade"] [data-animate-item]', {
  onEnter: function onEnter(batch) {
    return gsap.to(batch, {
      autoAlpha: 1,
      duration: 1,
      stagger: 0.5
    });
  },
  //когда скролим вниз при появление элемента во вьюпорте происходит анимация
  onLeave: function onLeave(batch) {
    return gsap.to(batch, {
      autoAlpha: 0,
      duration: 1,
      stagger: 0.5
    });
  },
  //когда элеменет пропадает с вьюпорта
  onEnterBack: function onEnterBack(batch) {
    return gsap.to(batch, {
      autoAlpha: 1,
      duration: 1,
      stagger: -0.5,
      delay: 1
    });
  },
  //когда скролим снизу вверх при повялении элемента во вьюпорте
  onLeaveBack: function onLeaveBack(batch) {
    return gsap.to(batch, {
      autoAlpha: 0,
      duration: 1,
      stagger: -0.5,
      delay: 0
    });
  },
  //когда скролим снизу вверх и элемент пропадает из вьюпорта
  start: 'bottom bottom',
  //первой значение област анимируемого элемента , второй параметр вьюпорт
  end: 'top top',
  //первой значение област анимируемого элемента , второй параметр вьюпорт
  scroller: _pageScroller.pageScroller //область где происходит скролл
}); //мы вешаем анимацию на все элементы c data-animate="fade", а точнее на ребенка внутри него

// const fadeInElements = document.querySelectorAll('[data-animate="fadeIn"] [data-animate-item]');
// gsap.set(fadeInElements, {autoAlpha: 0, y: '10%'});

_scrollTrigger.ScrollTrigger.batch('[data-animate="fadeIn"] [data-animate-item]', {
  onEnter: function onEnter(batch) {
    return gsap.to(batch, {
      autoAlpha: 1,
      y: 0,
      duration: 1,
      stagger: 0.5,
      delay: 0.5
    });
  },
  onLeave: function onLeave(batch) {
    return gsap.to(batch, {
      autoAlpha: 0,
      y: '10%',
      duration: 1,
      stagger: 0.5,
      delay: 0
    });
  },
  onEnterBack: function onEnterBack(batch) {
    return gsap.to(batch, {
      autoAlpha: 1,
      y: 0,
      duration: 1,
      stagger: -0.5,
      delay: 0.5
    });
  },
  onLeaveBack: function onLeaveBack(batch) {
    return gsap.to(batch, {
      autoAlpha: 0,
      y: '10%',
      duration: 1,
      stagger: -0.5,
      delay: 0
    });
  },
  start: 'bottom bottom',
  end: 'top top',
  scroller: _pageScroller.pageScroller
}); //мы вешаем анимацию на все элементы c data-animate="fadeIn", а точнее на ребенка внутри него

// const fadeScaleElements = document.querySelectorAll('[data-animate="fadeScale"] [data-animate-item]');
// gsap.set(fadeScaleElements, {autoAlpha: 0, scale: 0});

_scrollTrigger.ScrollTrigger.batch('[data-animate="fadeScale"] [data-animate-item]', {
  onEnter: function onEnter(batch) {
    return gsap.to(batch, {
      autoAlpha: 1,
      scale: 1,
      duration: 1,
      ease: 'back.out(1.5)',
      stagger: 0.5,
      delay: 1
    });
  },
  onLeave: function onLeave(batch) {
    return gsap.to(batch, {
      autoAlpha: 0,
      scale: 0,
      duration: 1,
      ease: 'back.out(1.5)',
      stagger: 0.5,
      delay: 0
    });
  },
  onEnterBack: function onEnterBack(batch) {
    return gsap.to(batch, {
      autoAlpha: 1,
      scale: 1,
      duration: 1,
      ease: 'back.out(1.5)',
      stagger: -0.5,
      delay: 0
    });
  },
  onLeaveBack: function onLeaveBack(batch) {
    return gsap.to(batch, {
      autoAlpha: 0,
      scale: 0,
      duration: 1,
      ease: 'back.out(1.5)',
      stagger: -0.5,
      delay: 0
    });
  },
  start: 'bottom+=57.5 bottom',
  //увеличиваем боттом на половину высоты элемента как как изначальное его скейл равен 0
  end: 'top top',
  scroller: _pageScroller.pageScroller
}); //мы вешаем анимацию на все элементы c data-animate="fadeScale", а точнее на ребенка внутри него

},{"../../utils/page-scroller.js":30,"../../vendor/scroll-trigger.js":33}],3:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateTimeline = void 0;
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
// ---
// generateTimeline module
// создает анимации по скроллу с помощью дата атрибута
var vpTouch = window.matchMedia('(pointer: coarse)');
var getObjectFromString = function getObjectFromString(str) {
  var output = {};
  if (str.includes('clipPath')) {
    var clipPathMatch = str.match(/clipPath: \((.*?)\)/);
    if (clipPathMatch) {
      output.clipPath = "(".concat(clipPathMatch[1].trim(), ")");
      str = str.replace(clipPathMatch[0], '');
    }
  } // добавляет в аутпут ключ clipPath и его значение + удаляет из передаваемой строки clipPath

  var properties = str.split(','); //оставшуюся строку преобразует в массив деля по запятой
  properties.forEach(function (property) {
    var _property$split$map = property.split(':').map(function (item) {
        return item.trim();
      }),
      _property$split$map2 = _slicedToArray(_property$split$map, 2),
      key = _property$split$map2[0],
      value = _property$split$map2[1];
    if (key && value) {
      output[key] = isNaN(Number(value)) ? value : Number(value);
    }
  }); //проходися по массиву и каждый элемент с помощью деструкции преобразуем в пару ключ значение , если значение число , делаем числом иначе строка

  return output;
}; //функция принимает строку парметр и конвертирует ее в объект джава скрипта

function getAnimationObject(el) {
  var obj = {};
  obj.direction = el.dataset.animationDirection;
  obj.duration = +el.dataset.animationDuration || 1;
  obj.delay = +el.dataset.animationDelay || 0;
  obj.position = el.dataset.position;
  obj.element = el;
  obj.animation = getObjectFromString(el.dataset.animation.toString());
  return obj;
} //возвращает обьект настроек для анимаций из дата атрибьюта элемента

var generateTimeline = function generateTimeline() {
  var sections = document.querySelectorAll('[data-section-animation]'); //ищем и записываем в констунту все элементы с соответствующем дата атрибьютом
  sections.forEach(function (section) {
    var blocks = gsap.utils.toArray(section.querySelectorAll("[data-animation]")).sort(function (a, b) {
      var aIndex = +a.dataset.index || 1;
      var bIndex = +b.dataset.index || 1;
      return aIndex - bIndex;
    }); //сортирует анимируемые блоки внутри родителей

    var tl = window.gsap.timeline({
      scrollTrigger: {
        scroller: vpTouch.matches ? '.wrapper' : 'body',
        //контейнер скролла
        trigger: section,
        //элемент на котором отрабатывают анимации
        start: section.dataset.start,
        //берем начало анимации из дата атрибьюта
        end: section.dataset.end,
        //берем конец анимации из дата атрибьюта
        scrub: section.dataset.scrub ? Number(section.dataset.scrub) : 1 ////анимация апдейтится в реальном времени по скролу , более плавно выглядит
      }
    }); //создаем кастомный таймлайн

    blocks.forEach(function (block) {
      var obj = getAnimationObject(block);
      if (obj.position) {
        tl[obj.direction](obj.element, _objectSpread({
          duration: obj.duration,
          delay: obj.delay
        }, obj.animation), obj.position);
      } else {
        tl[obj.direction](obj.element, _objectSpread({
          duration: obj.duration,
          delay: obj.delay
        }, obj.animation));
      }
    }); //для каждого блока полученного через гсап утилс ту аррэй мы устанавливаем параметры анимации обращаясь к созданному таймлайну, сами настрой мы получем из дата атр анимируемового блока использую функцию getAnimationObject()
  });
};
exports.generateTimeline = generateTimeline;

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initAnimationModule = void 0;
var _scrollSlider = require("./scroll-slider");
var _generateTimeline = require("./generate-timeline.js");
require("./batch-blocks");
var _parallax = require("./parallax.js");
var initAnimationModule = function initAnimationModule() {
  var sliderContainer = document.querySelector('[data-scroll-slider="parent"]');
  new _scrollSlider.ScrollSlider(sliderContainer);
  (0, _generateTimeline.generateTimeline)();
  (0, _parallax.initParallaxComponents)();
};
exports.initAnimationModule = initAnimationModule;

},{"./batch-blocks":2,"./generate-timeline.js":3,"./parallax.js":5,"./scroll-slider":6}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initParallaxComponents = void 0;
var _scrollTrigger = require("../../vendor/scroll-trigger.js");
var _pageScroller = require("../../utils/page-scroller.js");
var vp767 = window.matchMedia('(max-width: 767px)'); //возвращает true или false

var fadeScaleParallax = function fadeScaleParallax() {
  var items = document.querySelectorAll('[data-parallax="fadeScale"]'); //ищем анимируемые элементы
  if (!items.length) {
    return;
  } //если их нет останавливаем дальнейшее выполнение

  items.forEach(function (item) {
    var animateContainer = item.querySelector('[data-parallax="item"]');
    gsap.set(animateContainer, {
      opacity: 0,
      scale: 0.7
    }); //устанавливает изначальные свойства
    var tl = gsap.to(animateContainer, {
      opacity: 1,
      scale: 1
    }); //устанавливает финальный свойста
    _scrollTrigger.ScrollTrigger.create({
      trigger: item,
      //на ком запускается анимация
      scroller: _pageScroller.pageScroller,
      //контейнер скролла
      start: 'bottom bottom',
      //начало анимации нижняя граница элемента + низ вьюпорта
      end: vp767.matches ? 'center center' : 'top center',
      //конец анимациии на мобиле центр элемента центр вьюпорта, выше верх элемента центр вьюпорта
      scrub: true,
      //анимация апдейтится в реальном времени по скролу , более плавно выглядит
      animation: tl //константа анимации , что мы прописали выше
    });
  });
}; //функция добавляет анимации на элементы

var transformYParallax = function transformYParallax() {
  var items = document.querySelectorAll('[data-parallax="transformY"]'); //ищем анимируемые элементы
  if (!items.length) {
    return;
  } //если их нет останавливаем дальнейшее выполнение

  items.forEach(function (item) {
    var animateContainer = item.querySelector('[data-parallax="item"]');
    gsap.set(animateContainer, {
      y: item.dataset.from ? item.dataset.from : '100%'
    }); //устанавливает изначальные свойства , если есть дата атрибьют на элементе - то выставит его значение , если нет - то 100%
    var tl = gsap.to(animateContainer, {
      y: 0
    }); //устанавливает финальный свойста
    _scrollTrigger.ScrollTrigger.create({
      trigger: item,
      //на ком запускается анимация
      scroller: _pageScroller.pageScroller,
      //контейнер скролла
      start: 'top bottom',
      //начало анимации верхняя граница элемента + низ вьюпорта
      end: vp767.matches ? 'center center' : 'top center',
      //конец анимациии на мобиле центр элемента центр вьюпорта, выше верх элемента центр вьюпорта
      scrub: true,
      //анимация апдейтится в реальном времени по скролу , более плавно выглядит
      animation: tl //константа анимации , что мы прописали выше
    });
  });
};

var initParallaxComponents = function initParallaxComponents() {
  fadeScaleParallax();
  transformYParallax();
};
exports.initParallaxComponents = initParallaxComponents;

},{"../../utils/page-scroller.js":30,"../../vendor/scroll-trigger.js":33}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScrollSlider = void 0;
var _observers = require("../../utils/observers");
var _scrollTrigger = require("../../vendor/scroll-trigger.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var ScrollSlider = /*#__PURE__*/function () {
  function ScrollSlider(slider) {
    _classCallCheck(this, ScrollSlider);
    if (!slider) {
      return;
    }
    this.container = slider;
    this.slides = this.container.querySelectorAll('[data-scroll-slider="slide"]');
    this.slidesCount = this.slides.length;
    this.currentSlide = 0;
    this.timeline = null;
    this.vpTouch = window.matchMedia('(pointer: coarse)');
    this.setSlider = this.setSlider.bind(this);
    this.switchSlide = this.switchSlide.bind(this);
    this.init();
  } //кастом класс конструктор принимает элемент слайдер как параметр и инициализирует свойства и методы относящиеся к нему
  _createClass(ScrollSlider, [{
    key: "switchSlide",
    value: function switchSlide(scroll) {
      if (scroll.progress === 0) {
        this.currentSlide = 0;
      } else {
        this.currentSlide = Math.ceil(scroll.progress / (1 / this.slidesCount)) - 1;
      }
      _toConsumableArray(this.slides).map(function (slide) {
        return slide.classList.remove('is-active');
      });
      this.slides[this.currentSlide].classList.add('is-active');
    } //метод вызывается каждый раз , когда изменяется позиция скролла. Он высчитывает текущий слайд основываясь на скролл прогрессе и обновляет актив класс на текущем слайде снимая с других актив.
  }, {
    key: "updateHeight",
    value: function updateHeight() {
      this.height = this.slidesCount * window.innerHeight;
      this.container.style.minHeight = this.height + 'px';
    } // метод умножает высоюту вьюпорта на количество слайдов и вешает на контейнер минимальню высоту в пискселях основываясь на этих данных
  }, {
    key: "setSlider",
    value: function setSlider() {
      this.updateHeight(); //апдейт высоты контейнера

      if (this.timeline) {
        this.timeline.kill();
        this.timeline = null;
      } //проверка на существование сущности таймлайна для контейнера , если есть чистит

      this.timeline = gsap.timeline();
      _scrollTrigger.ScrollTrigger.create({
        scroller: this.vpTouch.matches ? '.wrapper' : 'body',
        //контейнер скролла
        trigger: this.container,
        //на ком запускается анимация
        start: 'top top',
        //верх контейнера и верх вьюпорта
        end: 'bottom bottom',
        //низ контейнера и низ вьюпорта
        scrub: true,
        //плавность
        onUpdate: this.switchSlide,
        //при обновлении скоролла запускается функция смены слайдов
        animation: this.timeline
      });
    } //инициализирует слайдер
  }, {
    key: "init",
    value: function init() {
      this.setSlider();
      _observers.resizeObserver.subscribe(this.setSlider); //привязываем сет к ресайзу , что б если высота слайдов менялась , а у нас она по высоте вьюпорта корректно перелистывались слайды
    } //вызывается во время инициализации класса слайдера
  }]);
  return ScrollSlider;
}();
exports.ScrollSlider = ScrollSlider;

},{"../../utils/observers":29,"../../vendor/scroll-trigger.js":33}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initHeaderModules = void 0;
var _observers = require("../../utils/observers.js");
var _setHeaderHeight = require("./set-header-height.js");
var _toggleMenu = require("./toggle-menu.js");
var initHeaderModules = function initHeaderModules() {
  _observers.resizeObserver.subscribe(_setHeaderHeight.setHeaderHeight); //добавляет в массив обсорверс ресайз обсервера функцию
  (0, _toggleMenu.initToggleMenu)(); //инициализация переключения состояний меню
};
exports.initHeaderModules = initHeaderModules;

},{"../../utils/observers.js":29,"./set-header-height.js":8,"./toggle-menu.js":9}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setHeaderHeight = void 0;
var setHeaderHeight = function setHeaderHeight() {
  var header = document.querySelector('.header'); //константа хэдера
  if (!header) {
    return;
  } //если хэдера нет останавливаем выполнение
  var headerRect = header.getBoundingClientRect(); //получаем параметры хэдера
  document.documentElement.style.setProperty('--header-height', headerRect.height + 'px'); //создание css переменной c значением высоты и запись ее на html
};
exports.setHeaderHeight = setHeaderHeight;

},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initToggleMenu = void 0;
var _observers = require("../../utils/observers.js");
var isMenuOpen = false; //Создаем переменную с дефолтным значением

var menuElements = {
  header: document.querySelector('.header'),
  //константа хэдера
  menuToggle: document.querySelector('[data-menu="toggle"]'),
  //константа бургер кнопки
  menuNav: document.querySelector('[data-menu="nav"]') //константа навигации
};

var closeMenu = function closeMenu() {
  menuElements.menuNav.classList.remove('is-active'); //снятие класса
  menuElements.menuToggle.classList.remove('is-active'); //снятие класса
  menuElements.header.classList.remove('menu-opened'); //снятие класса
  window.scrollLock.enableScrolling(); //включает скроллинг страницы
  isMenuOpen = false; //задает значение для переменной isMenuOpen
  _observers.keyObserver.unsubscribe(escKeyHandler); //убирает из массива обсерверс ки обсервера функцию
}; //функция закрытия меню

var openMenu = function openMenu() {
  menuElements.menuNav.classList.add('is-active'); //добавление класса
  menuElements.menuToggle.classList.add('is-active'); //добавление класса
  menuElements.header.classList.add('menu-opened'); //добавление класса
  window.scrollLock.disableScrolling(); //выключает скроллинг страницы
  isMenuOpen = true; //задает значение для переменной isMenuOpen
  _observers.keyObserver.subscribe(escKeyHandler); //добавляет в массив обсерверс ки обсервера функцию
}; //функция открытия меню

var escKeyHandler = function escKeyHandler(evt) {
  if (evt.key === 'Escape') {
    closeMenu();
  }
}; //хэндлер нажатия на esc

var toggleMenu = function toggleMenu(evt) {
  var target = evt.target; //цель клика
  var menuToggle = target.closest('[data-menu="toggle"]'); //получаем бургер как цель клика

  if (!menuToggle || !menuElements.menuNav) {
    return;
  } // еслин на странице нет бургер кнопки и нет навигации останавливаем дальнешие выполнение

  if (isMenuOpen) {
    closeMenu();
  } else {
    openMenu();
  } //если наша дефолтная переменная имеет значение true запускается функция closeMenu() , иначе openMenu()
}; //функция переключения двух состояний меню

var initToggleMenu = function initToggleMenu() {
  if (!menuElements.menuNav || !menuElements.menuToggle) {
    return;
  } //если на странице нет навигации или бургер кнопки, остановить функцию

  _observers.clickObserver.subscribe(toggleMenu); //добавление в массив обсерверс клик обсервера функцию
};
exports.initToggleMenu = initToggleMenu;

},{"../../utils/observers.js":29}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initScrollTo = void 0;
var _scrollToPlugin = require("../vendor/scroll-to-plugin");
var _pageScroller = require("../utils/page-scroller.js");
var _observers = require("../utils/observers");
var scrollToHandler = function scrollToHandler(evt) {
  var btn = evt.target.closest('[data-move-to]'); //кнопка которая запускает событие
  if (!btn) {
    return;
  }
  evt.preventDefault(); //отмена дефолтного поведения
  var target = document.querySelector(btn.dataset.moveTo); //цель куда перемещатся по нажатию на кнопку

  var options = {
    duration: Math.abs(btn.getBoundingClientRect().top - target.getBoundingClientRect().top) / (window.innerHeight * 2),
    offset: 0
  }; //объект настроек

  gsap.to(_pageScroller.pageScroller === 'body' ? window : _pageScroller.pageScroller, options.duration, {
    scrollTo: {
      y: target,
      offsetY: options.offset
    },
    ease: 'power4.out'
  }); //идет выбор к кому привязать анимацию , далее передаем настройки цели и оффсет
}; //хэндлер события нажатия на ссылку

var initScrollTo = function initScrollTo() {
  gsap.registerPlugin(_scrollToPlugin.ScrollToPlugin); //ругистрируем плагин
  if (!document.querySelector('[data-move-to]')) {
    return;
  }
  _observers.clickObserver.subscribe(scrollToHandler); //добавление в массив обсерверс клик обсервера функцию
}; //инициализация функции
exports.initScrollTo = initScrollTo;

},{"../utils/observers":29,"../utils/page-scroller.js":30,"../vendor/scroll-to-plugin":32}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initSplitter = void 0;
var _splitting = _interopRequireDefault(require("../vendor/splitting"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var initSplitter = function initSplitter() {
  var mySplitting = (0, _splitting.default)({
    by: 'lines'
  });
};
exports.initSplitter = initSplitter;

},{"../vendor/splitting":34}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Loader = void 0;
var _scrollLock = require("../utils/scroll-lock");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Loader = /*#__PURE__*/function () {
  function Loader() {
    _classCallCheck(this, Loader);
    this.container = document.querySelector('[data-loader="container"]'); //получаем контейнер в переменную
    if (!this.container) {
      return;
    } //если в дом нет data-loader='container' останавливаем дальнейшие действия
    this.box = this.container.querySelector('[data-loader="box"]'); //получем лоадер бокс внутри контейнера
    this.animateIntro = document.querySelector('[data-animate="intro"]'); //получаем блок интро

    this.scrollLock = new _scrollLock.ScrollLock(); //создаем скролл лок
    this.event = new Event('loaderOff'); //назначает новый объект Event с именем события «loaderOff». Это событие будет отправлено позже, чтобы указать, что загрузчик выключен.

    this.off = this.off.bind(this); //функция привязывается к текущему экземпляру класса Loader с помощью метода bind(). Это гарантирует, что ключевое слово this в этой функции относится к экземпляру Loader, даже если оно вызывается из разных контекстов.
    this.hide = this.hide.bind(this); //функция привязывается к текущему экземпляру класса Loader с помощью метода bind(). Это гарантирует, что ключевое слово this в этой функции относится к экземпляру Loader, даже если оно вызывается из разных контекстов.

    this.init(); //метод инициализации лоадера
  } // функция вызывается когда сущность лоадера создана
  _createClass(Loader, [{
    key: "hide",
    value: function hide() {
      this.hideTimeline = gsap.timeline(); //создаем gsap.timeline() объект
      this.hideTimeline = gsap.fromTo(this.container, {
        clipPath: 'polygon(0% 0%, 100% 0%, 100% 100%, 0% 110%)'
      }, {
        duration: 0.6,
        clipPath: 'polygon(0% 0%, 100% 0%, 100% 0%, 0% 0%)'
      }); //указываем анимацию скрытия от изначального состояния до конечного и указываем длительность перехода
      this.hideTimeline.then(this.off); //после отработки таймлайна вызываем метод off
    } //метод показывающий анимацию закрытия прелоадера и после запускающий метод off
  }, {
    key: "on",
    value: function on() {
      window.addEventListener('load', this.hide);
    } // когда весь контент страницы загружен вызывается метод hide
  }, {
    key: "off",
    value: function off() {
      document.querySelector('body').classList.remove('scroll-lock-ios'); //убираем класс с бади
      this.container.classList.add('is-hidden'); //добавляем контейнеру пролоадера класс
      window.dispatchEvent(this.event); //отправляет событие в общую систему событий
      if (this.animateIntro) {
        this.animateIntro.classList.add('is-shown');
      } //чекает есть ли на странице блок интро , если да - то добавляет класс
    } //метод полного скрытия прелоадера и запуск анимации интро
  }, {
    key: "init",
    value: function init() {
      this.on();
    } //инициализация лоадера
  }]);
  return Loader;
}();
exports.Loader = Loader;

},{"../utils/scroll-lock":31}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initClustersPins = void 0;
var initClustersPins = function initClustersPins(mapBlock, ymap) {
  var pinsArray = [];
  ymap.geoObjects.each(function (geoObject) {
    var pinType = geoObject.options.get('placemarkType');
    if (pinType !== 'mainPin') {
      pinsArray.push(geoObject);
    }
  });
  var customItemContentLayout = ymaps.templateLayoutFactory.createClass("<div class=\"cluster-balloon\">\n          <div class=\"cluster-balloon__image\">\n            <img src=\"$[properties.imagePath]\" width=\"101\" height=\"94\" alt=\"$[properties.imageAlt]\">\n          </div>\n          <div class=\"cluster-balloon__wrap\">\n            <p class=\"cluster-balloon__head\">$[properties.textHead]</p>\n            <p class=\"cluster-balloon__title\">$[properties.title]</p>\n            <p class=\"cluster-balloon__text {% if properties.textLeft %} cluster-balloon__text--right-text {% endif %}\">\n              {% if properties.text %}\n                {% if properties.linkHref %}\n                  <a href=\"$[properties.linkHref]\">$[properties.text]</a>\n                {% else %}\n                  <span>$[properties.text]</span>\n                {% endif %}\n              {% endif %}\n              {% if properties.textRight %}\n                <span class=\"right\">$[properties.textRight]</span>\n              {% endif %}\n            </p>\n          </div>\n        </div>");
  var clusterer = new ymaps.Clusterer({
    gridSize: 12800,
    preset: 'islands#brownClusterIcons',
    hasBalloon: true,
    hasHint: true,
    clusterDisableClickZoom: true,
    clusterOpenBalloonOnClick: true,
    // Устанавливаем стандартный макет балуна кластера "Карусель".
    clusterBalloonContentLayout: 'cluster#balloonCarousel',
    clusterBalloonItemContentLayout: customItemContentLayout,
    clusterBalloonPanelMaxMapArea: 0,
    clusterBalloonContentLayoutWidth: 300,
    clusterBalloonContentLayoutHeight: 180,
    clusterBalloonPagerSize: 5,
    clusterBalloonPagerType: 'marker'
  });
  clusterer.add(pinsArray);
  ymap.geoObjects.add(clusterer);
  ymap.setBounds(clusterer.getBounds(), {
    checkZoomRange: true
  });
};
exports.initClustersPins = initClustersPins;

},{}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initMapFilter = void 0;
var initMapFilter = function initMapFilter(mapBlock) {
  var list = document.querySelector('.map-filter');
  var getMapFilter = function getMapFilter(element) {
    var allPins = ymaps.geoQuery(mapBlock.geoObjects);
    if (element === 'all') {
      allPins.each(function (pm) {
        pm.options.set('visible', true);
      });
      return;
    }
    var arr = [];
    allPins.each(function (pm) {
      if (pm.options.get('placemarkType') === 'object') {
        return;
      }
      if (pm.options.get('placemarkType') === element) {
        pm.options.set('visible', true);
        arr.push(pm.balloon.isOpen());
      } else {
        pm.options.set('visible', false);
      }
      if (pm.options.get('placemarkType') === 'mainPin') {
        pm.options.set('visible', true);
      }
    });
    if (!arr.includes(true)) {
      mapBlock.balloon.close();
    }
  };
  list.addEventListener('change', function (evt) {
    evt.preventDefault();
    var target = evt.target.value;
    if (!target) {
      return;
    }
    getMapFilter(target);
  });
};
exports.initMapFilter = initMapFilter;

},{}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initMapPin = void 0;
var pinSize;
var offsetPin;
var pinContentLayout;
var renderDefaultPin = function renderDefaultPin() {
  pinSize = [90, 108];
  offsetPin = [-45, -120];
  pinContentLayout = "\n    <div class=\"map-pin\">\n      <div class=\"map-pin__logo\">\n        <svg width=\"90\" height=\"108\" aria-hidden=\"true\">\n          <use xlink:href=\"#icon-dino-pin\"></use>\n        </svg>\n      </div>\n    </div>\n  ";
};
var renderSmallPin = function renderSmallPin() {
  pinSize = [50, 60];
  offsetPin = [-25, -75];
  pinContentLayout = "\n    <div class=\"map-pin\">\n      <div class=\"map-pin__logo\">\n        <svg width=\"50\" height=\"60\" aria-hidden=\"true\">\n          <use xlink:href=\"#icon-dino-pin\"></use>\n        </svg>\n      </div>\n    </div>\n  ";
};
var initMapPin = function initMapPin(mapBlock, ymap, pin) {
  var placeCords = mapBlock.dataset.center.split(',');
  switch (pin) {
    case 'small':
      renderSmallPin();
      break;
    default:
      renderDefaultPin();
      break;
  }

  // Блок с меткой
  // eslint-disable-next-line no-undef
  var MyPlacemarkContentLayout = window.ymaps.templateLayoutFactory.createClass(pinContentLayout);

  // eslint-disable-next-line no-undef
  var myPlacemark = new window.ymaps.Placemark(placeCords, null, {
    // Опции.
    // Для меток с содержимым
    placemarkType: 'mainPin',
    iconLayout: 'default#imageWithContent',
    // Прячет стандартую иконку
    iconImageHref: '',
    // Размеры метки с содержимым
    iconContentSize: pinSize,
    // Смещение от точки привязки (левого верхнего угла) до ножки
    iconContentOffset: offsetPin,
    iconContentLayout: MyPlacemarkContentLayout,
    zIndex: 700
  });
  ymap.geoObjects.add(myPlacemark);
};
exports.initMapPin = initMapPin;

},{}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initCategoryPins = void 0;
var _fetch = require("../../utils/fetch.js");
var _initMapClusters = require("./init-map-clusters.js");
var initCategoryPins = function initCategoryPins(mapBlock, ymap) {
  var requestURL = mapBlock.dataset.markersUrl;
  var renderPins = function renderPins(data) {
    // Создаём макет содержимого.
    // eslint-disable-next-line no-undef
    var MyIconContentLayout = ymaps.templateLayoutFactory.createClass("<div class=\"placemark\" data-placemark tabindex=\"0\" data-map-marker=\"$[properties.category]\">\n            <div class=\"placemark__inner\">\n              <div class=\"placemark__icon\">\n                <svg width=\"40\" height=\"40\" aria-hidden=\"true\">\n                  <use xlink:href=\"#$[properties.icon]\"></use>\n                </svg>\n              </div>\n            </div>\n          </div>");

    // eslint-disable-next-line no-undef
    var MyBalloonLayout = ymaps.templateLayoutFactory.createClass("<div class=\"placemark-balloon\">\n          $[[options.contentLayout]]\n        </div>", {
      build: function build() {
        this.constructor.superclass.build.call(this);
        this._$parent = this.getParentElement();
        this._$element = this._$parent.querySelector('.placemark-balloon');
        this._$closeBtn = this._$element.querySelector('.placemark-balloon__close-btn');
        this.closeBtnCallback = window.ymaps.util.bind(this.onCloseClick, this);
        this._$closeBtn.addEventListener('click', this.closeBtnCallback);
        mapBlock.addEventListener('closeBalloon', this.closeBtnCallback);
      },
      onCloseClick: function onCloseClick(evt) {
        evt.preventDefault();
        ymap.balloon.close();
      }
    });

    // eslint-disable-next-line no-undef
    var MyBalloonContentLayout = ymaps.templateLayoutFactory.createClass("<div class=\"placemark-balloon__inner\">\n          {% if properties.imagePath %}\n            <div class=\"placemark-balloon__image\">\n              <img src=\"$[properties.imagePath]\" width=\"101\" height=\"94\" alt=\"$[properties.imageAlt]\">\n            </div>\n          {% endif %}\n          <div class=\"placemark-balloon__wrap\">\n            <p class=\"placemark-balloon__head\">$[properties.textHead]</p>\n            <p class=\"placemark-balloon__title\">$[properties.title]</p>\n            <p class=\"placemark-balloon__text {% if properties.textLeft %} placemark-balloon__text--right-text {% endif %}\">\n              {% if properties.text %}\n                {% if properties.linkHref %}\n                  <a href=\"$[properties.linkHref]\">$[properties.text]</a>\n                {% else %}\n                  <span>$[properties.text]</span>\n                {% endif %}\n              {% endif %}\n              {% if properties.textRight %}\n                <span class=\"right\">$[properties.textRight]</span>\n              {% endif %}\n            </p>\n          </div>\n          <button class=\"placemark-balloon__close-btn\" type=\"button\">\n            <svg width=\"12\" height=\"12\" aria-hidden=\"true\">\n              <use xlink:href=\"#icon-close\"></use>\n            </svg>\n          </button>\n        </div>");
    data.forEach(function (obj) {
      // eslint-disable-next-line no-undef
      var markers = new ymaps.Placemark(obj.latLng, {
        textHead: obj.textHead,
        title: obj.title,
        text: obj.text,
        textRight: obj.textRight,
        linkHref: obj.linkHref,
        imagePath: obj.imagePath,
        imageAlt: obj.imageAlt,
        category: obj.category,
        icon: obj.icon
      }, {
        // Опции.
        // Необходимо указать данный тип макета.
        iconLayout: 'default#imageWithContent',
        // Своё изображение иконки метки.
        iconImageHref: '',
        // Размеры метки.
        iconImageSize: [48, 48],
        // Смещение левого верхнего угла иконки относительно`
        // её "ножки" (точки привязки).
        iconImageOffset: [-24, -24],
        // Смещение слоя с содержимым относительно слоя с картинкой.
        // iconContentOffset: [15, 15],

        // Макет содержимого.
        placemarkType: obj.category,
        iconContentLayout: MyIconContentLayout,
        balloonLayout: MyBalloonLayout,
        balloonContentLayout: MyBalloonContentLayout,
        balloonPanelMaxMapArea: 0,
        // Не скрываем иконку при открытом балуне.
        hideIconOnBalloonOpen: false,
        balloonOffset: [0, -126]
      });
      ymap.geoObjects.add(markers);
    });
    if (mapBlock.dataset.cluster) {
      (0, _initMapClusters.initClustersPins)(mapBlock, ymap);
    }
  };
  var onSuccess = function onSuccess(data) {
    var mapMarkers = data.mapMarkers;
    renderPins(mapMarkers);
  };
  (0, _fetch.fetchApi)(requestURL, onSuccess);
};
exports.initCategoryPins = initCategoryPins;

},{"../../utils/fetch.js":25,"./init-map-clusters.js":13}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initZoomMap = void 0;
var mediaPoint = matchMedia('(max-width: 767px)');
var initZoomMap = function initZoomMap(ymap) {
  var messageBlock = document.querySelector('.ya-map__message');
  if (!messageBlock) {
    return;
  }
  var CTRL_KEY = 'Control';
  var TIMEOUT = 1500;
  var isCtrlKeyDown;
  var isCtrlMessageVisible;
  var timer;
  var showMessageBlock = function showMessageBlock() {
    messageBlock.classList.add('is-active');
    isCtrlMessageVisible = true;
    clearTimeout(timer);
    timer = setTimeout(hiddenMessageBlock, TIMEOUT);
  };
  var hiddenMessageBlock = function hiddenMessageBlock() {
    if (isCtrlMessageVisible) {
      messageBlock.classList.remove('is-active');
      isCtrlMessageVisible = false;
    }
  };
  var hiddenMessageBlockOnMousedown = function hiddenMessageBlockOnMousedown() {
    hiddenMessageBlock();
  };
  var enableScrollMapZoomOnKeydown = function enableScrollMapZoomOnKeydown(evt) {
    if (evt.key === CTRL_KEY && !isCtrlKeyDown) {
      isCtrlKeyDown = true;
      ymap.behaviors.enable('scrollZoom');
      // scroll.stop();
      hiddenMessageBlockOnMousedown();
    }
  };
  var disableScrollMapZoomOnKeyup = function disableScrollMapZoomOnKeyup(evt) {
    if (evt.key === CTRL_KEY) {
      isCtrlKeyDown = false;
      ymap.behaviors.disable('scrollZoom');
      // scroll.start();
    }
  };

  var onMapWheel = function onMapWheel() {
    if (!isCtrlKeyDown) {
      showMessageBlock();
    } else {
      hiddenMessageBlock();
    }
  };
  var breakpointChecker = function breakpointChecker() {
    if (!mediaPoint.matches) {
      document.addEventListener('keydown', enableScrollMapZoomOnKeydown);
      document.addEventListener('keyup', disableScrollMapZoomOnKeyup);
      messageBlock.addEventListener('mousedown', hiddenMessageBlockOnMousedown);
      messageBlock.addEventListener('wheel', onMapWheel);
      ymap.events.add('wheel', onMapWheel);
    } else {
      document.removeEventListener('keydown', enableScrollMapZoomOnKeydown);
      document.removeEventListener('keyup', disableScrollMapZoomOnKeyup);
      messageBlock.removeEventListener('mousedown', hiddenMessageBlockOnMousedown);
      messageBlock.removeEventListener('wheel', onMapWheel);
      ymap.events.remove('wheel', onMapWheel);
    }
  };
  breakpointChecker();
  mediaPoint.addListener(breakpointChecker);
};
exports.initZoomMap = initZoomMap;

},{}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initMaps = void 0;
var _map = require("./map-1.js");
var _map2 = require("./map-2.js");
var _map3 = require("./map-3.js");
var _map4 = require("./map-4.js");
var initDefaultMap = function initDefaultMap(mapBlock) {
  // eslint-disable-next-line
  window.ymaps.ready(function () {
    // eslint-disable-next-line
    var myMap = new window.ymaps.Map(mapBlock, {
      center: [55.755819, 37.617644],
      zoom: 15,
      behaviors: ['drag', 'multiTouch']
    }, {
      suppressMapOpenBlock: true,
      searchControlProvider: 'yandex#search'
    });
  });
};
var initSetupMap = function initSetupMap(mapId, mapBlock) {
  switch (mapId) {
    case 'map-4':
      (0, _map4.initMap4)(mapBlock);
      break;
    case 'map-3':
      (0, _map3.initMap3)(mapBlock);
      break;
    case 'map-2':
      (0, _map2.initMap2)(mapBlock);
      break;
    case 'map-1':
      (0, _map.initMap1)(mapBlock);
      break;
    default:
      initDefaultMap(mapBlock);
  }
};
var initMaps = function initMaps() {
  var mapBlocks = document.querySelectorAll('.ya-map__map');
  if (!mapBlocks.length) {
    return;
  }
  mapBlocks.forEach(function (mapBlock) {
    var mapId = mapBlock.dataset.map;
    initSetupMap(mapId, mapBlock);
  });
};
exports.initMaps = initMaps;

},{"./map-1.js":19,"./map-2.js":20,"./map-3.js":21,"./map-4.js":22}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initMap1 = void 0;
var _initMapPin = require("./init-map-pin.js");
var _initMapZoom = require("./init-map-zoom.js");
var initMap1 = function initMap1(mapBlock) {
  var center = mapBlock.dataset.center.split(', ').map(function (str) {
    return +str;
  });
  var zoom = +mapBlock.dataset.zoom;
  var controls = mapBlock.dataset.controls ? mapBlock.dataset.controls.split(' ') : [];
  var behaviorsMap = ['drag', 'multiTouch'];
  window.ymaps.ready(function () {
    var myMap = new ymaps.Map(mapBlock, {
      center: center,
      zoom: zoom,
      controls: controls,
      behaviors: behaviorsMap
    }, {
      autoFitToViewport: 'always'
    });
    (0, _initMapPin.initMapPin)(mapBlock, myMap);
  });
};
exports.initMap1 = initMap1;

},{"./init-map-pin.js":15,"./init-map-zoom.js":17}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initMap2 = void 0;
var _initMapPin = require("./init-map-pin.js");
var _initMapPins = require("./init-map-pins.js");
var initMap2 = function initMap2(mapBlock) {
  var center = mapBlock.dataset.center.split(', ').map(function (str) {
    return +str;
  });
  var zoom = +mapBlock.dataset.zoom;
  var controls = mapBlock.dataset.controls ? mapBlock.dataset.controls.split(' ') : [];
  var behaviorsMap = ['drag', 'multiTouch'];
  window.ymaps.ready(function () {
    var myMap = new ymaps.Map(mapBlock, {
      center: center,
      zoom: zoom,
      controls: controls,
      behaviors: behaviorsMap
    }, {
      autoFitToViewport: 'always'
    });
    (0, _initMapPin.initMapPin)(mapBlock, myMap, 'small');
    (0, _initMapPins.initCategoryPins)(mapBlock, myMap);
  });
};
exports.initMap2 = initMap2;

},{"./init-map-pin.js":15,"./init-map-pins.js":16}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initMap3 = void 0;
var _initMapPin = require("./init-map-pin.js");
var _initMapPins = require("./init-map-pins.js");
var _initMapFilter = require("./init-map-filter.js");
var _initMapZoom = require("./init-map-zoom.js");
var initMap3 = function initMap3(mapBlock) {
  var center = mapBlock.dataset.center.split(', ').map(function (str) {
    return +str;
  });
  var zoom = +mapBlock.dataset.zoom;
  var controls = mapBlock.dataset.controls ? mapBlock.dataset.controls.split(' ') : [];
  var behaviorsMap = ['drag', 'multiTouch'];
  window.ymaps.ready(function () {
    var myMap = new ymaps.Map(mapBlock, {
      center: center,
      zoom: zoom,
      controls: controls,
      behaviors: behaviorsMap
    }, {
      autoFitToViewport: 'always'
    });
    (0, _initMapPin.initMapPin)(mapBlock, myMap, 'small');
    (0, _initMapPins.initCategoryPins)(mapBlock, myMap);
    (0, _initMapFilter.initMapFilter)(myMap);
    (0, _initMapZoom.initZoomMap)(myMap);
  });
};
exports.initMap3 = initMap3;

},{"./init-map-filter.js":14,"./init-map-pin.js":15,"./init-map-pins.js":16,"./init-map-zoom.js":17}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initMap4 = void 0;
var _initMapPin = require("./init-map-pin.js");
var _initMapPins = require("./init-map-pins.js");
var _initMapZoom = require("./init-map-zoom.js");
var initMap4 = function initMap4(mapBlock) {
  var center = mapBlock.dataset.center.split(', ').map(function (str) {
    return +str;
  });
  var zoom = +mapBlock.dataset.zoom;
  var controls = mapBlock.dataset.controls ? mapBlock.dataset.controls.split(' ') : [];
  var behaviorsMap = ['drag', 'multiTouch'];
  window.ymaps.ready(function () {
    var myMap = new ymaps.Map(mapBlock, {
      center: center,
      zoom: zoom,
      controls: controls,
      behaviors: behaviorsMap
    }, {
      autoFitToViewport: 'always'
    });
    (0, _initMapPin.initMapPin)(mapBlock, myMap, 'small');
    (0, _initMapPins.initCategoryPins)(mapBlock, myMap);
    (0, _initMapZoom.initZoomMap)(myMap);
  });
};
exports.initMap4 = initMap4;

},{"./init-map-pin.js":15,"./init-map-pins.js":16,"./init-map-zoom.js":17}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.modals = exports.initModals = void 0;
var _modals = require("./modals");
var modals;

// Здесь реализован пример открытия модалки через колбэк закрытия
// const openModalInCloseCallback = (name, context = this) => {
//   context._enableScrolling = false;
//   context._setSettings('default');
//   modals.open(name);
// };

// closeCallback() {
//   openModalInCloseCallback('modal-5');
// },
exports.modals = modals;
var settings = {
  'default': {
    preventDefault: true,
    stopPlay: true,
    lockFocus: true,
    startFocus: true,
    focusBack: true,
    eventTimeout: 400,
    openCallback: false,
    closeCallback: false
  }
};
var initModals = function initModals() {
  var modalElements = document.querySelectorAll('.modal');
  if (modalElements.length) {
    modalElements.forEach(function (el) {
      setTimeout(function () {
        el.classList.remove('modal--preload');
      }, 100);
    });
  }
  exports.modals = modals = new _modals.Modals(settings);
  // Используйте в разработке экспортируемую переменную modals, window сделан для бэкэнда
  window.modals = modals;
};
exports.initModals = initModals;

},{"./modals":24}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Modals = void 0;
var _scrollLock = require("../../utils/scroll-lock");
var _focusLock = require("../../utils/focus-lock");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Modals = /*#__PURE__*/function () {
  function Modals() {
    var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, Modals);
    this._scrollLock = new _scrollLock.ScrollLock();
    this._focusLock = new _focusLock.FocusLock();
    this._modalOpenElements = document.querySelectorAll('[data-open-modal]');
    this._stackModalElements = [];
    this._openedModalElement = null;
    this._modalName = null;
    this._enableScrolling = true;
    this._settingKey = 'default';
    this._settings = settings;
    this._preventDefault = this._settings[this._settingKey].preventDefault;
    this._stopPlay = this._settings[this._settingKey].stopPlay;
    this._lockFocus = this._settings[this._settingKey].lockFocus;
    this._startFocus = this._settings[this._settingKey].startFocus;
    this._focusBack = this._settings[this._settingKey].focusBack;
    this._eventTimeout = this._settings[this._settingKey].eventTimeout;
    this._resetScrollPos = this._settings[this._settingKey].resetScrollPos;
    this._openCallback = this._settings[this._settingKey].openCallback;
    this._closeCallback = this._settings[this._settingKey].closeCallback;
    this._documentKeydownHandler = this._documentKeydownHandler.bind(this);
    this._documentClickHandler = this._documentClickHandler.bind(this);
    this._modalClickHandler = this._modalClickHandler.bind(this);
    this._init();
  }
  _createClass(Modals, [{
    key: "_init",
    value: function _init() {
      if (this._modalOpenElements.length) {
        document.addEventListener('click', this._documentClickHandler);
      }
    }
  }, {
    key: "_setSettings",
    value: function _setSettings() {
      var settingKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._settingKey;
      if (!this._settings[settingKey]) {
        return;
      }
      this._preventDefault = typeof this._settings[settingKey].preventDefault === 'boolean' ? this._settings[settingKey].preventDefault : this._settings[this._settingKey].preventDefault;
      this._stopPlay = typeof this._settings[settingKey].stopPlay === 'boolean' ? this._settings[settingKey].stopPlay : this._settings[this._settingKey].stopPlay;
      this._lockFocus = typeof this._settings[settingKey].lockFocus === 'boolean' ? this._settings[settingKey].lockFocus : this._settings[this._settingKey].lockFocus;
      this._startFocus = typeof this._settings[settingKey].startFocus === 'boolean' ? this._settings[settingKey].startFocus : this._settings[this._settingKey].startFocus;
      this._focusBack = typeof this._settings[settingKey].lockFocus === 'boolean' ? this._settings[settingKey].focusBack : this._settings[this._settingKey].focusBack;
      this._resetScrollPos = typeof this._settings[settingKey].resetScrollPos === 'boolean' ? this._settings[settingKey].resetScrollPos : this._settings[this._settingKey].resetScrollPos;
      this._eventTimeout = typeof this._settings[settingKey].eventTimeout === 'number' ? this._settings[settingKey].eventTimeout : this._settings[this._settingKey].eventTimeout;
      this._openCallback = this._settings[settingKey].openCallback || this._settings[this._settingKey].openCallback;
      this._closeCallback = this._settings[settingKey].closeCallback || this._settings[this._settingKey].closeCallback;
    }
  }, {
    key: "_documentClickHandler",
    value: function _documentClickHandler(evt) {
      var target = evt.target;
      if (!target.closest('[data-open-modal]')) {
        return;
      }
      evt.preventDefault();
      this._modalName = target.closest('[data-open-modal]').dataset.openModal;
      if (!this._modalName) {
        return;
      }
      this.open();
    }
  }, {
    key: "_documentKeydownHandler",
    value: function _documentKeydownHandler(evt) {
      var isEscKey = evt.key === 'Escape' || evt.key === 'Esc';
      if (isEscKey) {
        evt.preventDefault();
        this.close(document.querySelector('.modal.is-active').dataset.modal);
      }
    }
  }, {
    key: "_modalClickHandler",
    value: function _modalClickHandler(evt) {
      var target = evt.target;
      if (!target.closest('[data-close-modal]')) {
        return;
      }
      if (target.closest('[data-close-modal="back"]')) {
        this.back();
      } else {
        this.close(target.closest('[data-modal]').dataset.modal);
        this._stackModalElements = [];
      }
    }
  }, {
    key: "_addListeners",
    value: function _addListeners(modal) {
      modal.addEventListener('click', this._modalClickHandler);
      document.addEventListener('keydown', this._documentKeydownHandler);
    }
  }, {
    key: "_removeListeners",
    value: function _removeListeners(modal) {
      modal.removeEventListener('click', this._modalClickHandler);
      document.removeEventListener('keydown', this._documentKeydownHandler);
    }
  }, {
    key: "_stopInteractive",
    value: function _stopInteractive(modal) {
      if (this._stopPlay) {
        modal.querySelectorAll('video, audio').forEach(function (el) {
          return el.pause();
        });
        modal.querySelectorAll('[data-iframe]').forEach(function (el) {
          el.querySelector('iframe').contentWindow.postMessage('{"event": "command", "func": "pauseVideo", "args": ""}', '*');
        });
      }
    }
  }, {
    key: "_autoPlay",
    value: function _autoPlay(modal) {
      modal.querySelectorAll('[data-iframe]').forEach(function (el) {
        var autoPlay = el.closest('[data-auto-play]');
        if (autoPlay) {
          el.querySelector('iframe').contentWindow.postMessage('{"event":"command","func":"playVideo","args":""}', '*');
        }
      });
    }
  }, {
    key: "open",
    value: function open() {
      var _this = this;
      var modalName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._modalName;
      var modal = document.querySelector("[data-modal=\"".concat(modalName, "\"]"));
      if (!modal || modal.classList.contains('is-active')) {
        return;
      }
      document.removeEventListener('click', this._documentClickHandler);
      this._openedModalElement = document.querySelector('.modal.is-active');
      if (this._openedModalElement) {
        this._enableScrolling = false;
        this.close(this._openedModalElement.dataset.modal);
      }
      this._setSettings(modalName);
      modal.classList.add('is-active');
      if (modalName !== this._stackModalElements[this._stackModalElements.length - 1]) {
        this._stackModalElements.push(modalName);
      }
      if (!this._openedModalElement) {
        this._scrollLock.disableScrolling();
      }
      if (this._openCallback) {
        this._openCallback();
      }
      if (this._lockFocus) {
        this._focusLock.lock('.modal.is-active', this._startFocus);
      }
      if (this._resetScrollPos) {
        modal.scrollTo(0, 0);
      }
      setTimeout(function () {
        _this._addListeners(modal);
        _this._autoPlay(modal);
        document.addEventListener('click', _this._documentClickHandler);
      }, this._eventTimeout);
    }
  }, {
    key: "back",
    value: function back() {
      if (!this._stackModalElements.length) {
        return;
      }
      var activeModal = this._stackModalElements[this._stackModalElements.length - 1];
      var prevModal = this._stackModalElements[this._stackModalElements.length - 2];
      if (this._stackModalElements.length === 1) {
        this._stackModalElements = [];
      }
      if (prevModal) {
        this._stackModalElements.pop();
        this.open(prevModal);
      }
      this.close(activeModal);
    }
  }, {
    key: "close",
    value: function close() {
      var _this2 = this;
      var modalName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._modalName;
      var modal = document.querySelector("[data-modal=\"".concat(modalName, "\"]"));
      document.removeEventListener('click', this._documentClickHandler);
      if (!modal || !modal.classList.contains('is-active')) {
        return;
      }
      if (this._lockFocus) {
        this._focusLock.unlock(this._focusBack);
      }
      modal.classList.remove('is-active');
      this._removeListeners(modal);
      this._stopInteractive(modal);
      if (this._closeCallback) {
        this._closeCallback();
      }
      if (this._enableScrolling) {
        setTimeout(function () {
          _this2._scrollLock.enableScrolling();
        }, this._eventTimeout);
      }
      setTimeout(function () {
        document.addEventListener('click', _this2._documentClickHandler);
      }, this._eventTimeout);
      this._setSettings('default');
      this._enableScrolling = true;
    }
  }]);
  return Modals;
}();
exports.Modals = Modals;

},{"../../utils/focus-lock":26,"../../utils/scroll-lock":31}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchApi = void 0;
var fetchApi = function fetchApi(url, onSuccess, onError) {
  return fetch(url).then(function (res) {
    if (!res.ok) {
      throw new Error(res.status);
    }
    return res.json();
  }).then(function (data) {
    if (onSuccess) {
      onSuccess(data);
    }
    return data;
  }).catch(function (err) {
    if (onError) {
      onError(err);
    } else {
      console.error(err); // eslint-disable-line no-console
    }
  });
};
exports.fetchApi = fetchApi;

},{}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FocusLock = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var SELECTORS = ['a[href]', 'area[href]', 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', 'select:not([disabled]):not([aria-hidden])', 'textarea:not([disabled]):not([aria-hidden])', 'button:not([disabled]):not([aria-hidden])', 'iframe', 'object', 'embed', '[contenteditable]', '[tabindex]:not([tabindex^="-"])'];
var FocusLock = /*#__PURE__*/function () {
  function FocusLock() {
    _classCallCheck(this, FocusLock);
    this._lockedSelector = null;
    this._focusableElements = null;
    this._endElement = null;
    this._selectors = SELECTORS;
    this._documentKeydownHandler = this._documentKeydownHandler.bind(this);
  }
  _createClass(FocusLock, [{
    key: "_documentKeydownHandler",
    value: function _documentKeydownHandler(evt) {
      var activeElement = document.activeElement;
      if (evt.key === 'Tab') {
        if (!this._focusableElements.length) {
          evt.preventDefault();
          activeElement.blur();
          return;
        }
        if (this._focusableElements.length === 1) {
          evt.preventDefault();
          this._focusableElements[0].focus();
          return;
        }
        if (this._focusableElements.length > 1 && !activeElement.closest(this._lockedSelector)) {
          evt.preventDefault();
          this._focusableElements[0].focus();
          return;
        }
      }
      if (evt.key === 'Tab' && !evt.shiftKey && activeElement === this._focusableElements[this._focusableElements.length - 1]) {
        evt.preventDefault();
        this._focusableElements[0].focus();
      }
      if (evt.key === 'Tab' && evt.shiftKey && activeElement === this._focusableElements[0]) {
        evt.preventDefault();
        this._focusableElements[this._focusableElements.length - 1].focus();
      }
    }
  }, {
    key: "lock",
    value: function lock(lockedSelector) {
      var startFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.unlock();
      this._lockedSelector = lockedSelector;
      var lockedElement = document.querySelector(this._lockedSelector);
      if (!lockedElement) {
        return;
      }
      this._focusableElements = lockedElement.querySelectorAll(this._selectors);
      this._endElement = document.activeElement;
      var startElement = lockedElement.querySelector('[data-focus]') || this._focusableElements[0];
      if (this._endElement) {
        this._endElement.blur();
      }
      if (startElement && startFocus) {
        startElement.focus();
      }
      document.addEventListener('keydown', this._documentKeydownHandler);
    }
  }, {
    key: "unlock",
    value: function unlock() {
      var returnFocus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (this._endElement && returnFocus) {
        this._endElement.focus();
      }
      this._lockedSelector = null;
      this._focusableElements = null;
      this._endElement = null;
      document.removeEventListener('keydown', this._documentKeydownHandler);
    }
  }]);
  return FocusLock;
}();
exports.FocusLock = FocusLock;
window.focusLock = new FocusLock();

},{}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.iosChecker = void 0;
var iosChecker = function iosChecker() {
  return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform)
  // iPad on iOS 13 detection
  || navigator.userAgent.includes('Mac') && 'ontouchend' in document;
};
exports.iosChecker = iosChecker;

},{}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.iosVhFix = void 0;
var _iosChecker = require("./ios-checker");
var iosVhFix = function iosVhFix() {
  if (!(!!window.MSInputMethodContext && !!document.documentMode)) {
    if ((0, _iosChecker.iosChecker)()) {
      var vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', "".concat(vh, "px"));
      window.addEventListener('resize', function () {
        vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', "".concat(vh, "px"));
      });
    }
  }
};
exports.iosVhFix = iosVhFix;

},{"./ios-checker":27}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resizeObserver = exports.keyObserver = exports.clickObserver = exports.EventObserver = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var EventObserver = /*#__PURE__*/function () {
  function EventObserver() {
    _classCallCheck(this, EventObserver);
    this.observers = [];
    this.fire = this.fire.bind(this);
  }
  _createClass(EventObserver, [{
    key: "subscribe",
    value: function subscribe(fn) {
      this.observers.push(fn);
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(fn) {
      this.observers = this.observers.filter(function (subscriber) {
        return subscriber !== fn;
      });
    }
  }, {
    key: "fire",
    value: function fire(data) {
      this.observers.forEach(function (subscriber) {
        return subscriber(data);
      });
    }
  }]);
  return EventObserver;
}();
exports.EventObserver = EventObserver;
var resizeObserver = new EventObserver();
exports.resizeObserver = resizeObserver;
var resizeObserverProto = new ResizeObserver(function () {
  return setTimeout(function () {
    return resizeObserver.fire('resize');
  }, 10);
});
resizeObserverProto.observe(document.documentElement);
var keyObserver = new EventObserver();
exports.keyObserver = keyObserver;
window.addEventListener('keydown', keyObserver.fire);
var clickObserver = new EventObserver();
exports.clickObserver = clickObserver;
window.addEventListener('click', clickObserver.fire);

},{}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pageScroller = void 0;
var vpTouch = window.matchMedia('(pointer: coarse)');
var pageScroller = vpTouch.matches ? '.wrapper' : 'body';
exports.pageScroller = pageScroller;

},{}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScrollLock = void 0;
var _iosChecker = require("./ios-checker");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var ScrollLock = /*#__PURE__*/function () {
  function ScrollLock() {
    _classCallCheck(this, ScrollLock);
    this._iosChecker = _iosChecker.iosChecker;
    this._lockClass = this._iosChecker() ? 'scroll-lock-ios' : 'scroll-lock';
    this._scrollTop = null;
    this._fixedBlockElements = document.querySelectorAll('[data-fix-block]');
  }
  _createClass(ScrollLock, [{
    key: "_getScrollbarWidth",
    value: function _getScrollbarWidth() {
      return window.innerWidth - document.documentElement.clientWidth;
    }
  }, {
    key: "_getBodyScrollTop",
    value: function _getBodyScrollTop() {
      return self.pageYOffset || document.documentElement && document.documentElement.ScrollTop || document.body && document.body.scrollTop;
    }
  }, {
    key: "disableScrolling",
    value: function disableScrolling() {
      var _this = this;
      this._scrollTop = document.body.dataset.scroll = document.body.dataset.scroll ? document.body.dataset.scroll : this._getBodyScrollTop();
      if (this._getScrollbarWidth()) {
        document.body.style.paddingRight = "".concat(this._getScrollbarWidth(), "px");
        this._fixedBlockElements.forEach(function (block) {
          block.style.paddingRight = "".concat(_this._getScrollbarWidth(), "px");
        });
      }
      document.body.style.top = "-".concat(this._scrollTop, "px");
      document.body.classList.add(this._lockClass);
    }
  }, {
    key: "enableScrolling",
    value: function enableScrolling() {
      document.body.classList.remove(this._lockClass);
      window.scrollTo(0, +document.body.dataset.scroll);
      document.body.style.paddingRight = null;
      document.body.style.top = null;
      this._fixedBlockElements.forEach(function (block) {
        block.style.paddingRight = null;
      });
      document.body.removeAttribute('data-scroll');
      this._scrollTop = null;
    }
  }]);
  return ScrollLock;
}();
exports.ScrollLock = ScrollLock;
window.scrollLock = new ScrollLock();

},{"./ios-checker":27}],32:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
/* !
 * ScrollToPlugin 3.11.4
 * https://greensock.com
 *
 * @license Copyright 2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

!function (e, t) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? t(exports) : typeof define === 'function' && define.amd ? define(['exports'], t) : t((e = e || self).window = e.window || {});
}(void 0, function (e) {
  'use strict';

  function l() {
    return typeof window !== 'undefined';
  }
  function m() {
    return f || l() && (f = window.gsap) && f.registerPlugin && f;
  }
  function n(e) {
    return typeof e === 'string';
  }
  function o(e) {
    return typeof e === 'function';
  }
  function p(e, t) {
    var o = t === 'x' ? 'Width' : 'Height';
    var n = 'scroll' + o;
    var l = 'client' + o;
    return e === T || e === i || e === c ? Math.max(i[n], c[n]) - (T['inner' + o] || i[l] || c[l]) : e[n] - e['offset' + o];
  }
  function q(e, t) {
    var o = 'scroll' + (t === 'x' ? 'Left' : 'Top');
    return e === T && (e.pageXOffset != null ? o = 'page' + t.toUpperCase() + 'Offset' : e = i[o] != null ? i : c), function () {
      return e[o];
    };
  }
  function s(e, t) {
    if (!(e = y(e)[0]) || !e.getBoundingClientRect) {
      return console.warn('scrollTo target doesn\'t exist. Using 0') || {
        x: 0,
        y: 0
      };
    }
    var o = e.getBoundingClientRect();
    var n = !t || t === T || t === c;
    var l = n ? {
      top: i.clientTop - (T.pageYOffset || i.scrollTop || c.scrollTop || 0),
      left: i.clientLeft - (T.pageXOffset || i.scrollLeft || c.scrollLeft || 0)
    } : t.getBoundingClientRect();
    var r = {
      x: o.left - l.left,
      y: o.top - l.top
    };
    return !n && t && (r.x += q(t, 'x')(), r.y += q(t, 'y')()), r;
  }
  function t(e, t, o, l, r) {
    return isNaN(e) || _typeof(e) === 'object' ? n(e) && e.charAt(1) === '=' ? parseFloat(e.substr(2)) * (e.charAt(0) === '-' ? -1 : 1) + l - r : e === 'max' ? p(t, o) - r : Math.min(p(t, o), s(e, t)[o] - r) : parseFloat(e) - r;
  }
  function u() {
    f = m(), l() && f && typeof document !== 'undefined' && document.body && (T = window, c = document.body, i = document.documentElement, y = f.utils.toArray, f.config({
      autoKillThreshold: 7
    }), v = f.config(), a = 1);
  }
  var f;
  var a;
  var T;
  var i;
  var c;
  var y;
  var v;
  var h;
  var r = {
    version: '3.11.4',
    name: 'scrollTo',
    rawVars: 1,
    register: function register(e) {
      f = e, u();
    },
    init: function init(e, l, r, s, i) {
      a || u();
      var p = this;
      var c = f.getProperty(e, 'scrollSnapType');
      p.isWin = e === T, p.target = e, p.tween = r, l = function _clean(e, t, l, r) {
        if (o(e) && (e = e(t, l, r)), _typeof(e) !== 'object') {
          return n(e) && e !== 'max' && e.charAt(1) !== '=' ? {
            x: e,
            y: e
          } : {
            y: e
          };
        }
        if (e.nodeType) {
          return {
            y: e,
            x: e
          };
        }
        var s;
        var i = {};
        for (s in e) {
          i[s] = s !== 'onAutoKill' && o(e[s]) ? e[s](t, l, r) : e[s];
        }
        return i;
      }(l, s, e, i), p.vars = l, p.autoKill = !!l.autoKill, p.getX = q(e, 'x'), p.getY = q(e, 'y'), p.x = p.xPrev = p.getX(), p.y = p.yPrev = p.getY(), h = h || f.core.globals().ScrollTrigger, f.getProperty(e, 'scrollBehavior') === 'smooth' && f.set(e, {
        scrollBehavior: 'auto'
      }), c && c !== 'none' && (p.snap = 1, p.snapInline = e.style.scrollSnapType, e.style.scrollSnapType = 'none'), l.x != null ? (p.add(p, 'x', p.x, t(l.x, e, 'x', p.x, l.offsetX || 0), s, i), p._props.push('scrollTo_x')) : p.skipX = 1, l.y != null ? (p.add(p, 'y', p.y, t(l.y, e, 'y', p.y, l.offsetY || 0), s, i), p._props.push('scrollTo_y')) : p.skipY = 1;
    },
    render: function render(e, t) {
      for (var o, n, l, r, s, i = t._pt, c = t.target, u = t.tween, f = t.autoKill, a = t.xPrev, y = t.yPrev, d = t.isWin, g = t.snap, x = t.snapInline; i;) {
        i.r(e, i.d), i = i._next;
      }
      o = d || !t.skipX ? t.getX() : a, l = (n = d || !t.skipY ? t.getY() : y) - y, r = o - a, s = v.autoKillThreshold, t.x < 0 && (t.x = 0), t.y < 0 && (t.y = 0), f && (!t.skipX && (s < r || r < -s) && o < p(c, 'x') && (t.skipX = 1), !t.skipY && (s < l || l < -s) && n < p(c, 'y') && (t.skipY = 1), t.skipX && t.skipY && (u.kill(), t.vars.onAutoKill && t.vars.onAutoKill.apply(u, t.vars.onAutoKillParams || []))), d ? T.scrollTo(t.skipX ? o : t.x, t.skipY ? n : t.y) : (t.skipY || (c.scrollTop = t.y), t.skipX || (c.scrollLeft = t.x)), !g || e !== 1 && e !== 0 || (n = c.scrollTop, o = c.scrollLeft, x ? c.style.scrollSnapType = x : c.style.removeProperty('scroll-snap-type'), c.scrollTop = n + 1, c.scrollLeft = o + 1, c.scrollTop = n, c.scrollLeft = o), t.xPrev = t.x, t.yPrev = t.y, h && h.update();
    },
    kill: function kill(e) {
      var t = e === 'scrollTo';
      !t && e !== 'scrollTo_x' || (this.skipX = 1), !t && e !== 'scrollTo_y' || (this.skipY = 1);
    }
  };
  r.max = p, r.getOffset = s, r.buildGetter = q, m() && f.registerPlugin(r), e.ScrollToPlugin = r, e.default = r;
  if (typeof window === 'undefined' || window !== e) {
    Object.defineProperty(e, '__esModule', {
      value: !0
    });
  } else {
    delete e.default;
  }
});

},{}],33:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.window = global.window || {}));
})(void 0, function (exports) {
  'use strict';

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  /*!
   * Observer 3.11.5
   * https://greensock.com
   *
   * @license Copyright 2008-2023, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  var gsap,
    _coreInitted,
    _clamp,
    _win,
    _doc,
    _docEl,
    _body,
    _isTouch,
    _pointerType,
    ScrollTrigger,
    _root,
    _normalizer,
    _eventTypes,
    _context,
    _getGSAP = function _getGSAP() {
      return gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap;
    },
    _startup = 1,
    _observers = [],
    _scrollers = [],
    _proxies = [],
    _getTime = Date.now,
    _bridge = function _bridge(name, value) {
      return value;
    },
    _integrate = function _integrate() {
      var core = ScrollTrigger.core,
        data = core.bridge || {},
        scrollers = core._scrollers,
        proxies = core._proxies;
      scrollers.push.apply(scrollers, _scrollers);
      proxies.push.apply(proxies, _proxies);
      _scrollers = scrollers;
      _proxies = proxies;
      _bridge = function _bridge(name, value) {
        return data[name](value);
      };
    },
    _getProxyProp = function _getProxyProp(element, property) {
      return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
    },
    _isViewport = function _isViewport(el) {
      return !!~_root.indexOf(el);
    },
    _addListener = function _addListener(element, type, func, nonPassive, capture) {
      return element.addEventListener(type, func, {
        passive: !nonPassive,
        capture: !!capture
      });
    },
    _removeListener = function _removeListener(element, type, func, capture) {
      return element.removeEventListener(type, func, !!capture);
    },
    _scrollLeft = "scrollLeft",
    _scrollTop = "scrollTop",
    _onScroll = function _onScroll() {
      return _normalizer && _normalizer.isPressed || _scrollers.cache++;
    },
    _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {
      var cachingFunc = function cachingFunc(value) {
        if (value || value === 0) {
          _startup && (_win.history.scrollRestoration = "manual");
          var isNormalizing = _normalizer && _normalizer.isPressed;
          value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0);
          f(value);
          cachingFunc.cacheID = _scrollers.cache;
          isNormalizing && _bridge("ss", value);
        } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge("ref")) {
          cachingFunc.cacheID = _scrollers.cache;
          cachingFunc.v = f();
        }
        return cachingFunc.v + cachingFunc.offset;
      };
      cachingFunc.offset = 0;
      return f && cachingFunc;
    },
    _horizontal = {
      s: _scrollLeft,
      p: "left",
      p2: "Left",
      os: "right",
      os2: "Right",
      d: "width",
      d2: "Width",
      a: "x",
      sc: _scrollCacheFunc(function (value) {
        return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;
      })
    },
    _vertical = {
      s: _scrollTop,
      p: "top",
      p2: "Top",
      os: "bottom",
      os2: "Bottom",
      d: "height",
      d2: "Height",
      a: "y",
      op: _horizontal,
      sc: _scrollCacheFunc(function (value) {
        return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;
      })
    },
    _getTarget = function _getTarget(t) {
      return gsap.utils.toArray(t)[0] || (typeof t === "string" && gsap.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
    },
    _getScrollFunc = function _getScrollFunc(element, _ref) {
      var s = _ref.s,
        sc = _ref.sc;
      _isViewport(element) && (element = _doc.scrollingElement || _docEl);
      var i = _scrollers.indexOf(element),
        offset = sc === _vertical.sc ? 1 : 2;
      !~i && (i = _scrollers.push(element) - 1);
      _scrollers[i + offset] || element.addEventListener("scroll", _onScroll);
      var prev = _scrollers[i + offset],
        func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function (value) {
          return arguments.length ? element[s] = value : element[s];
        })));
      func.target = element;
      prev || (func.smooth = gsap.getProperty(element, "scrollBehavior") === "smooth");
      return func;
    },
    _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {
      var v1 = value,
        v2 = value,
        t1 = _getTime(),
        t2 = t1,
        min = minTimeRefresh || 50,
        dropToZeroTime = Math.max(500, min * 3),
        update = function update(value, force) {
          var t = _getTime();
          if (force || t - t1 > min) {
            v2 = v1;
            v1 = value;
            t2 = t1;
            t1 = t;
          } else if (useDelta) {
            v1 += value;
          } else {
            v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);
          }
        },
        reset = function reset() {
          v2 = v1 = useDelta ? 0 : v1;
          t2 = t1 = 0;
        },
        getVelocity = function getVelocity(latestValue) {
          var tOld = t2,
            vOld = v2,
            t = _getTime();
          (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
          return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;
        };
      return {
        update: update,
        reset: reset,
        getVelocity: getVelocity
      };
    },
    _getEvent = function _getEvent(e, preventDefault) {
      preventDefault && !e._gsapAllow && e.preventDefault();
      return e.changedTouches ? e.changedTouches[0] : e;
    },
    _getAbsoluteMax = function _getAbsoluteMax(a) {
      var max = Math.max.apply(Math, a),
        min = Math.min.apply(Math, a);
      return Math.abs(max) >= Math.abs(min) ? max : min;
    },
    _setScrollTrigger = function _setScrollTrigger() {
      ScrollTrigger = gsap.core.globals().ScrollTrigger;
      ScrollTrigger && ScrollTrigger.core && _integrate();
    },
    _initCore = function _initCore(core) {
      gsap = core || _getGSAP();
      if (gsap && typeof document !== "undefined" && document.body) {
        _win = window;
        _doc = document;
        _docEl = _doc.documentElement;
        _body = _doc.body;
        _root = [_win, _doc, _docEl, _body];
        _clamp = gsap.utils.clamp;
        _context = gsap.core.context || function () {};
        _pointerType = "onpointerenter" in _body ? "pointer" : "mouse";
        _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
        _eventTypes = Observer.eventTypes = ("ontouchstart" in _docEl ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
        setTimeout(function () {
          return _startup = 0;
        }, 500);
        _setScrollTrigger();
        _coreInitted = 1;
      }
      return _coreInitted;
    };
  _horizontal.op = _vertical;
  _scrollers.cache = 0;
  var Observer = function () {
    function Observer(vars) {
      this.init(vars);
    }
    var _proto = Observer.prototype;
    _proto.init = function init(vars) {
      _coreInitted || _initCore(gsap) || console.warn("Please gsap.registerPlugin(Observer)");
      ScrollTrigger || _setScrollTrigger();
      var tolerance = vars.tolerance,
        dragMinimum = vars.dragMinimum,
        type = vars.type,
        target = vars.target,
        lineHeight = vars.lineHeight,
        debounce = vars.debounce,
        preventDefault = vars.preventDefault,
        onStop = vars.onStop,
        onStopDelay = vars.onStopDelay,
        ignore = vars.ignore,
        wheelSpeed = vars.wheelSpeed,
        event = vars.event,
        onDragStart = vars.onDragStart,
        onDragEnd = vars.onDragEnd,
        onDrag = vars.onDrag,
        onPress = vars.onPress,
        onRelease = vars.onRelease,
        onRight = vars.onRight,
        onLeft = vars.onLeft,
        onUp = vars.onUp,
        onDown = vars.onDown,
        onChangeX = vars.onChangeX,
        onChangeY = vars.onChangeY,
        onChange = vars.onChange,
        onToggleX = vars.onToggleX,
        onToggleY = vars.onToggleY,
        onHover = vars.onHover,
        onHoverEnd = vars.onHoverEnd,
        onMove = vars.onMove,
        ignoreCheck = vars.ignoreCheck,
        isNormalizer = vars.isNormalizer,
        onGestureStart = vars.onGestureStart,
        onGestureEnd = vars.onGestureEnd,
        onWheel = vars.onWheel,
        onEnable = vars.onEnable,
        onDisable = vars.onDisable,
        onClick = vars.onClick,
        scrollSpeed = vars.scrollSpeed,
        capture = vars.capture,
        allowClicks = vars.allowClicks,
        lockAxis = vars.lockAxis,
        onLockAxis = vars.onLockAxis;
      this.target = target = _getTarget(target) || _docEl;
      this.vars = vars;
      ignore && (ignore = gsap.utils.toArray(ignore));
      tolerance = tolerance || 1e-9;
      dragMinimum = dragMinimum || 0;
      wheelSpeed = wheelSpeed || 1;
      scrollSpeed = scrollSpeed || 1;
      type = type || "wheel,touch,pointer";
      debounce = debounce !== false;
      lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22);
      var id,
        onStopDelayedCall,
        dragged,
        moved,
        wheeled,
        locked,
        axis,
        self = this,
        prevDeltaX = 0,
        prevDeltaY = 0,
        scrollFuncX = _getScrollFunc(target, _horizontal),
        scrollFuncY = _getScrollFunc(target, _vertical),
        scrollX = scrollFuncX(),
        scrollY = scrollFuncY(),
        limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown",
        isViewport = _isViewport(target),
        ownerDoc = target.ownerDocument || _doc,
        deltaX = [0, 0, 0],
        deltaY = [0, 0, 0],
        onClickTime = 0,
        clickCapture = function clickCapture() {
          return onClickTime = _getTime();
        },
        _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {
          return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
        },
        onStopFunc = function onStopFunc() {
          self._vx.reset();
          self._vy.reset();
          onStopDelayedCall.pause();
          onStop && onStop(self);
        },
        update = function update() {
          var dx = self.deltaX = _getAbsoluteMax(deltaX),
            dy = self.deltaY = _getAbsoluteMax(deltaY),
            changedX = Math.abs(dx) >= tolerance,
            changedY = Math.abs(dy) >= tolerance;
          onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY);
          if (changedX) {
            onRight && self.deltaX > 0 && onRight(self);
            onLeft && self.deltaX < 0 && onLeft(self);
            onChangeX && onChangeX(self);
            onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);
            prevDeltaX = self.deltaX;
            deltaX[0] = deltaX[1] = deltaX[2] = 0;
          }
          if (changedY) {
            onDown && self.deltaY > 0 && onDown(self);
            onUp && self.deltaY < 0 && onUp(self);
            onChangeY && onChangeY(self);
            onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);
            prevDeltaY = self.deltaY;
            deltaY[0] = deltaY[1] = deltaY[2] = 0;
          }
          if (moved || dragged) {
            onMove && onMove(self);
            if (dragged) {
              onDrag(self);
              dragged = false;
            }
            moved = false;
          }
          locked && !(locked = false) && onLockAxis && onLockAxis(self);
          if (wheeled) {
            onWheel(self);
            wheeled = false;
          }
          id = 0;
        },
        onDelta = function onDelta(x, y, index) {
          deltaX[index] += x;
          deltaY[index] += y;
          self._vx.update(x);
          self._vy.update(y);
          debounce ? id || (id = requestAnimationFrame(update)) : update();
        },
        onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {
          if (lockAxis && !axis) {
            self.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
            locked = true;
          }
          if (axis !== "y") {
            deltaX[2] += x;
            self._vx.update(x, true);
          }
          if (axis !== "x") {
            deltaY[2] += y;
            self._vy.update(y, true);
          }
          debounce ? id || (id = requestAnimationFrame(update)) : update();
        },
        _onDrag = function _onDrag(e) {
          if (_ignoreCheck(e, 1)) {
            return;
          }
          e = _getEvent(e, preventDefault);
          var x = e.clientX,
            y = e.clientY,
            dx = x - self.x,
            dy = y - self.y,
            isDragging = self.isDragging;
          self.x = x;
          self.y = y;
          if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {
            onDrag && (dragged = true);
            isDragging || (self.isDragging = true);
            onTouchOrPointerDelta(dx, dy);
            isDragging || onDragStart && onDragStart(self);
          }
        },
        _onPress = self.onPress = function (e) {
          if (_ignoreCheck(e, 1) || e && e.button) {
            return;
          }
          self.axis = axis = null;
          onStopDelayedCall.pause();
          self.isPressed = true;
          e = _getEvent(e);
          prevDeltaX = prevDeltaY = 0;
          self.startX = self.x = e.clientX;
          self.startY = self.y = e.clientY;
          self._vx.reset();
          self._vy.reset();
          _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, preventDefault, true);
          self.deltaX = self.deltaY = 0;
          onPress && onPress(self);
        },
        _onRelease = self.onRelease = function (e) {
          if (_ignoreCheck(e, 1)) {
            return;
          }
          _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
          var isTrackingDrag = !isNaN(self.y - self.startY),
            wasDragging = self.isDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),
            eventData = _getEvent(e);
          if (!wasDragging && isTrackingDrag) {
            self._vx.reset();
            self._vy.reset();
            if (preventDefault && allowClicks) {
              gsap.delayedCall(0.08, function () {
                if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {
                  if (e.target.click) {
                    e.target.click();
                  } else if (ownerDoc.createEvent) {
                    var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                    syntheticEvent.initMouseEvent("click", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                    e.target.dispatchEvent(syntheticEvent);
                  }
                }
              });
            }
          }
          self.isDragging = self.isGesturing = self.isPressed = false;
          onStop && !isNormalizer && onStopDelayedCall.restart(true);
          onDragEnd && wasDragging && onDragEnd(self);
          onRelease && onRelease(self, wasDragging);
        },
        _onGestureStart = function _onGestureStart(e) {
          return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);
        },
        _onGestureEnd = function _onGestureEnd() {
          return (self.isGesturing = false) || onGestureEnd(self);
        },
        onScroll = function onScroll(e) {
          if (_ignoreCheck(e)) {
            return;
          }
          var x = scrollFuncX(),
            y = scrollFuncY();
          onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
          scrollX = x;
          scrollY = y;
          onStop && onStopDelayedCall.restart(true);
        },
        _onWheel = function _onWheel(e) {
          if (_ignoreCheck(e)) {
            return;
          }
          e = _getEvent(e, preventDefault);
          onWheel && (wheeled = true);
          var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;
          onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
          onStop && !isNormalizer && onStopDelayedCall.restart(true);
        },
        _onMove = function _onMove(e) {
          if (_ignoreCheck(e)) {
            return;
          }
          var x = e.clientX,
            y = e.clientY,
            dx = x - self.x,
            dy = y - self.y;
          self.x = x;
          self.y = y;
          moved = true;
          (dx || dy) && onTouchOrPointerDelta(dx, dy);
        },
        _onHover = function _onHover(e) {
          self.event = e;
          onHover(self);
        },
        _onHoverEnd = function _onHoverEnd(e) {
          self.event = e;
          onHoverEnd(self);
        },
        _onClick = function _onClick(e) {
          return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);
        };
      onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
      self.deltaX = self.deltaY = 0;
      self._vx = _getVelocityProp(0, 50, true);
      self._vy = _getVelocityProp(0, 50, true);
      self.scrollX = scrollFuncX;
      self.scrollY = scrollFuncY;
      self.isDragging = self.isGesturing = self.isPressed = false;
      _context(this);
      self.enable = function (e) {
        if (!self.isEnabled) {
          _addListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
          type.indexOf("scroll") >= 0 && _addListener(isViewport ? ownerDoc : target, "scroll", onScroll, preventDefault, capture);
          type.indexOf("wheel") >= 0 && _addListener(target, "wheel", _onWheel, preventDefault, capture);
          if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
            _addListener(target, _eventTypes[0], _onPress, preventDefault, capture);
            _addListener(ownerDoc, _eventTypes[2], _onRelease);
            _addListener(ownerDoc, _eventTypes[3], _onRelease);
            allowClicks && _addListener(target, "click", clickCapture, false, true);
            onClick && _addListener(target, "click", _onClick);
            onGestureStart && _addListener(ownerDoc, "gesturestart", _onGestureStart);
            onGestureEnd && _addListener(ownerDoc, "gestureend", _onGestureEnd);
            onHover && _addListener(target, _pointerType + "enter", _onHover);
            onHoverEnd && _addListener(target, _pointerType + "leave", _onHoverEnd);
            onMove && _addListener(target, _pointerType + "move", _onMove);
          }
          self.isEnabled = true;
          e && e.type && _onPress(e);
          onEnable && onEnable(self);
        }
        return self;
      };
      self.disable = function () {
        if (self.isEnabled) {
          _observers.filter(function (o) {
            return o !== self && _isViewport(o.target);
          }).length || _removeListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
          if (self.isPressed) {
            self._vx.reset();
            self._vy.reset();
            _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
          }
          _removeListener(isViewport ? ownerDoc : target, "scroll", onScroll, capture);
          _removeListener(target, "wheel", _onWheel, capture);
          _removeListener(target, _eventTypes[0], _onPress, capture);
          _removeListener(ownerDoc, _eventTypes[2], _onRelease);
          _removeListener(ownerDoc, _eventTypes[3], _onRelease);
          _removeListener(target, "click", clickCapture, true);
          _removeListener(target, "click", _onClick);
          _removeListener(ownerDoc, "gesturestart", _onGestureStart);
          _removeListener(ownerDoc, "gestureend", _onGestureEnd);
          _removeListener(target, _pointerType + "enter", _onHover);
          _removeListener(target, _pointerType + "leave", _onHoverEnd);
          _removeListener(target, _pointerType + "move", _onMove);
          self.isEnabled = self.isPressed = self.isDragging = false;
          onDisable && onDisable(self);
        }
      };
      self.kill = self.revert = function () {
        self.disable();
        var i = _observers.indexOf(self);
        i >= 0 && _observers.splice(i, 1);
        _normalizer === self && (_normalizer = 0);
      };
      _observers.push(self);
      isNormalizer && _isViewport(target) && (_normalizer = self);
      self.enable(event);
    };
    _createClass(Observer, [{
      key: "velocityX",
      get: function get() {
        return this._vx.getVelocity();
      }
    }, {
      key: "velocityY",
      get: function get() {
        return this._vy.getVelocity();
      }
    }]);
    return Observer;
  }();
  Observer.version = "3.11.5";
  Observer.create = function (vars) {
    return new Observer(vars);
  };
  Observer.register = _initCore;
  Observer.getAll = function () {
    return _observers.slice();
  };
  Observer.getById = function (id) {
    return _observers.filter(function (o) {
      return o.vars.id === id;
    })[0];
  };
  _getGSAP() && gsap.registerPlugin(Observer);

  /*!
   * ScrollTrigger 3.11.5
   * https://greensock.com
   *
   * @license Copyright 2008-2023, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */

  var gsap$1,
    _coreInitted$1,
    _win$1,
    _doc$1,
    _docEl$1,
    _body$1,
    _root$1,
    _resizeDelay,
    _toArray,
    _clamp$1,
    _time2,
    _syncInterval,
    _refreshing,
    _pointerIsDown,
    _transformProp,
    _i,
    _prevWidth,
    _prevHeight,
    _autoRefresh,
    _sort,
    _suppressOverwrites,
    _ignoreResize,
    _normalizer$1,
    _ignoreMobileResize,
    _baseScreenHeight,
    _baseScreenWidth,
    _fixIOSBug,
    _context$1,
    _scrollRestoration,
    _limitCallbacks,
    _startup$1 = 1,
    _getTime$1 = Date.now,
    _time1 = _getTime$1(),
    _lastScrollTime = 0,
    _enabled = 0,
    _rafBugFix = function _rafBugFix() {
      return _enabled && requestAnimationFrame(_rafBugFix);
    },
    _pointerDownHandler = function _pointerDownHandler() {
      return _pointerIsDown = 1;
    },
    _pointerUpHandler = function _pointerUpHandler() {
      return _pointerIsDown = 0;
    },
    _passThrough = function _passThrough(v) {
      return v;
    },
    _round = function _round(value) {
      return Math.round(value * 100000) / 100000 || 0;
    },
    _windowExists = function _windowExists() {
      return typeof window !== "undefined";
    },
    _getGSAP$1 = function _getGSAP() {
      return gsap$1 || _windowExists() && (gsap$1 = window.gsap) && gsap$1.registerPlugin && gsap$1;
    },
    _isViewport$1 = function _isViewport(e) {
      return !!~_root$1.indexOf(e);
    },
    _getBoundsFunc = function _getBoundsFunc(element) {
      return _getProxyProp(element, "getBoundingClientRect") || (_isViewport$1(element) ? function () {
        _winOffsets.width = _win$1.innerWidth;
        _winOffsets.height = _win$1.innerHeight;
        return _winOffsets;
      } : function () {
        return _getBounds(element);
      });
    },
    _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {
      var d = _ref.d,
        d2 = _ref.d2,
        a = _ref.a;
      return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function () {
        return a()[d];
      } : function () {
        return (isViewport ? _win$1["inner" + d2] : scroller["client" + d2]) || 0;
      };
    },
    _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {
      return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function () {
        return _winOffsets;
      };
    },
    _maxScroll = function _maxScroll(element, _ref2) {
      var s = _ref2.s,
        d2 = _ref2.d2,
        d = _ref2.d,
        a = _ref2.a;
      return Math.max(0, (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport$1(element) ? (_docEl$1[s] || _body$1[s]) - (_win$1["inner" + d2] || _docEl$1["client" + d2] || _body$1["client" + d2]) : element[s] - element["offset" + d2]);
    },
    _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
      for (var i = 0; i < _autoRefresh.length; i += 3) {
        (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
      }
    },
    _isString = function _isString(value) {
      return typeof value === "string";
    },
    _isFunction = function _isFunction(value) {
      return typeof value === "function";
    },
    _isNumber = function _isNumber(value) {
      return typeof value === "number";
    },
    _isObject = function _isObject(value) {
      return _typeof(value) === "object";
    },
    _endAnimation = function _endAnimation(animation, reversed, pause) {
      return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
    },
    _callback = function _callback(self, func) {
      if (self.enabled) {
        var result = func(self);
        result && result.totalTime && (self.callbackAnimation = result);
      }
    },
    _abs = Math.abs,
    _left = "left",
    _top = "top",
    _right = "right",
    _bottom = "bottom",
    _width = "width",
    _height = "height",
    _Right = "Right",
    _Left = "Left",
    _Top = "Top",
    _Bottom = "Bottom",
    _padding = "padding",
    _margin = "margin",
    _Width = "Width",
    _Height = "Height",
    _px = "px",
    _getComputedStyle = function _getComputedStyle(element) {
      return _win$1.getComputedStyle(element);
    },
    _makePositionable = function _makePositionable(element) {
      var position = _getComputedStyle(element).position;
      element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
    },
    _setDefaults = function _setDefaults(obj, defaults) {
      for (var p in defaults) {
        p in obj || (obj[p] = defaults[p]);
      }
      return obj;
    },
    _getBounds = function _getBounds(element, withoutTransforms) {
      var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap$1.to(element, {
          x: 0,
          y: 0,
          xPercent: 0,
          yPercent: 0,
          rotation: 0,
          rotationX: 0,
          rotationY: 0,
          scale: 1,
          skewX: 0,
          skewY: 0
        }).progress(1),
        bounds = element.getBoundingClientRect();
      tween && tween.progress(0).kill();
      return bounds;
    },
    _getSize = function _getSize(element, _ref3) {
      var d2 = _ref3.d2;
      return element["offset" + d2] || element["client" + d2] || 0;
    },
    _getLabelRatioArray = function _getLabelRatioArray(timeline) {
      var a = [],
        labels = timeline.labels,
        duration = timeline.duration(),
        p;
      for (p in labels) {
        a.push(labels[p] / duration);
      }
      return a;
    },
    _getClosestLabel = function _getClosestLabel(animation) {
      return function (value) {
        return gsap$1.utils.snap(_getLabelRatioArray(animation), value);
      };
    },
    _snapDirectional = function _snapDirectional(snapIncrementOrArray) {
      var snap = gsap$1.utils.snap(snapIncrementOrArray),
        a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function (a, b) {
          return a - b;
        });
      return a ? function (value, direction, threshold) {
        if (threshold === void 0) {
          threshold = 1e-3;
        }
        var i;
        if (!direction) {
          return snap(value);
        }
        if (direction > 0) {
          value -= threshold;
          for (i = 0; i < a.length; i++) {
            if (a[i] >= value) {
              return a[i];
            }
          }
          return a[i - 1];
        } else {
          i = a.length;
          value += threshold;
          while (i--) {
            if (a[i] <= value) {
              return a[i];
            }
          }
        }
        return a[0];
      } : function (value, direction, threshold) {
        if (threshold === void 0) {
          threshold = 1e-3;
        }
        var snapped = snap(value);
        return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
      };
    },
    _getLabelAtDirection = function _getLabelAtDirection(timeline) {
      return function (value, st) {
        return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);
      };
    },
    _multiListener = function _multiListener(func, element, types, callback) {
      return types.split(",").forEach(function (type) {
        return func(element, type, callback);
      });
    },
    _addListener$1 = function _addListener(element, type, func, nonPassive, capture) {
      return element.addEventListener(type, func, {
        passive: !nonPassive,
        capture: !!capture
      });
    },
    _removeListener$1 = function _removeListener(element, type, func, capture) {
      return element.removeEventListener(type, func, !!capture);
    },
    _wheelListener = function _wheelListener(func, el, scrollFunc) {
      scrollFunc = scrollFunc && scrollFunc.wheelHandler;
      if (scrollFunc) {
        func(el, "wheel", scrollFunc);
        func(el, "touchmove", scrollFunc);
      }
    },
    _markerDefaults = {
      startColor: "green",
      endColor: "red",
      indent: 0,
      fontSize: "16px",
      fontWeight: "normal"
    },
    _defaults = {
      toggleActions: "play",
      anticipatePin: 0
    },
    _keywords = {
      top: 0,
      left: 0,
      center: 0.5,
      bottom: 1,
      right: 1
    },
    _offsetToPx = function _offsetToPx(value, size) {
      if (_isString(value)) {
        var eqIndex = value.indexOf("="),
          relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;
        if (~eqIndex) {
          value.indexOf("%") > eqIndex && (relative *= size / 100);
          value = value.substr(0, eqIndex - 1);
        }
        value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
      }
      return value;
    },
    _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {
      var startColor = _ref4.startColor,
        endColor = _ref4.endColor,
        fontSize = _ref4.fontSize,
        indent = _ref4.indent,
        fontWeight = _ref4.fontWeight;
      var e = _doc$1.createElement("div"),
        useFixedPosition = _isViewport$1(container) || _getProxyProp(container, "pinType") === "fixed",
        isScroller = type.indexOf("scroller") !== -1,
        parent = useFixedPosition ? _body$1 : container,
        isStart = type.indexOf("start") !== -1,
        color = isStart ? startColor : endColor,
        css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
      css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
      (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
      matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
      e._isStart = isStart;
      e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
      e.style.cssText = css;
      e.innerText = name || name === 0 ? type + "-" + name : type;
      parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
      e._offset = e["offset" + direction.op.d2];
      _positionMarker(e, 0, direction, isStart);
      return e;
    },
    _positionMarker = function _positionMarker(marker, start, direction, flipped) {
      var vars = {
          display: "block"
        },
        side = direction[flipped ? "os2" : "p2"],
        oppositeSide = direction[flipped ? "p2" : "os2"];
      marker._isFlipped = flipped;
      vars[direction.a + "Percent"] = flipped ? -100 : 0;
      vars[direction.a] = flipped ? "1px" : 0;
      vars["border" + side + _Width] = 1;
      vars["border" + oppositeSide + _Width] = 0;
      vars[direction.p] = start + "px";
      gsap$1.set(marker, vars);
    },
    _triggers = [],
    _ids = {},
    _rafID,
    _sync = function _sync() {
      return _getTime$1() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));
    },
    _onScroll$1 = function _onScroll() {
      if (!_normalizer$1 || !_normalizer$1.isPressed || _normalizer$1.startX > _body$1.clientWidth) {
        _scrollers.cache++;
        if (_normalizer$1) {
          _rafID || (_rafID = requestAnimationFrame(_updateAll));
        } else {
          _updateAll();
        }
        _lastScrollTime || _dispatch("scrollStart");
        _lastScrollTime = _getTime$1();
      }
    },
    _setBaseDimensions = function _setBaseDimensions() {
      _baseScreenWidth = _win$1.innerWidth;
      _baseScreenHeight = _win$1.innerHeight;
    },
    _onResize = function _onResize() {
      _scrollers.cache++;
      !_refreshing && !_ignoreResize && !_doc$1.fullscreenElement && !_doc$1.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win$1.innerWidth || Math.abs(_win$1.innerHeight - _baseScreenHeight) > _win$1.innerHeight * 0.25) && _resizeDelay.restart(true);
    },
    _listeners = {},
    _emptyArray = [],
    _softRefresh = function _softRefresh() {
      return _removeListener$1(ScrollTrigger$1, "scrollEnd", _softRefresh) || _refreshAll(true);
    },
    _dispatch = function _dispatch(type) {
      return _listeners[type] && _listeners[type].map(function (f) {
        return f();
      }) || _emptyArray;
    },
    _savedStyles = [],
    _revertRecorded = function _revertRecorded(media) {
      for (var i = 0; i < _savedStyles.length; i += 5) {
        if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {
          _savedStyles[i].style.cssText = _savedStyles[i + 1];
          _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
          _savedStyles[i + 3].uncache = 1;
        }
      }
    },
    _revertAll = function _revertAll(kill, media) {
      var trigger;
      for (_i = 0; _i < _triggers.length; _i++) {
        trigger = _triggers[_i];
        if (trigger && (!media || trigger._ctx === media)) {
          if (kill) {
            trigger.kill(1);
          } else {
            trigger.revert(true, true);
          }
        }
      }
      media && _revertRecorded(media);
      media || _dispatch("revert");
    },
    _clearScrollMemory = function _clearScrollMemory(scrollRestoration, force) {
      _scrollers.cache++;
      (force || !_refreshingAll) && _scrollers.forEach(function (obj) {
        return _isFunction(obj) && obj.cacheID++ && (obj.rec = 0);
      });
      _isString(scrollRestoration) && (_win$1.history.scrollRestoration = _scrollRestoration = scrollRestoration);
    },
    _refreshingAll,
    _refreshID = 0,
    _queueRefreshID,
    _queueRefreshAll = function _queueRefreshAll() {
      if (_queueRefreshID !== _refreshID) {
        var id = _queueRefreshID = _refreshID;
        requestAnimationFrame(function () {
          return id === _refreshID && _refreshAll(true);
        });
      }
    },
    _refreshAll = function _refreshAll(force, skipRevert) {
      if (_lastScrollTime && !force) {
        _addListener$1(ScrollTrigger$1, "scrollEnd", _softRefresh);
        return;
      }
      _refreshingAll = ScrollTrigger$1.isRefreshing = true;
      _scrollers.forEach(function (obj) {
        return _isFunction(obj) && obj.cacheID++ && (obj.rec = obj());
      });
      var refreshInits = _dispatch("refreshInit");
      _sort && ScrollTrigger$1.sort();
      skipRevert || _revertAll();
      _scrollers.forEach(function (obj) {
        if (_isFunction(obj)) {
          obj.smooth && (obj.target.style.scrollBehavior = "auto");
          obj(0);
        }
      });
      _triggers.slice(0).forEach(function (t) {
        return t.refresh();
      });
      _triggers.forEach(function (t, i) {
        if (t._subPinOffset && t.pin) {
          var prop = t.vars.horizontal ? "offsetWidth" : "offsetHeight",
            original = t.pin[prop];
          t.revert(true, 1);
          t.adjustPinSpacing(t.pin[prop] - original);
          t.refresh();
        }
      });
      _triggers.forEach(function (t) {
        return t.vars.end === "max" && t.setPositions(t.start, Math.max(t.start + 1, _maxScroll(t.scroller, t._dir)));
      });
      refreshInits.forEach(function (result) {
        return result && result.render && result.render(-1);
      });
      _scrollers.forEach(function (obj) {
        if (_isFunction(obj)) {
          obj.smooth && requestAnimationFrame(function () {
            return obj.target.style.scrollBehavior = "smooth";
          });
          obj.rec && obj(obj.rec);
        }
      });
      _clearScrollMemory(_scrollRestoration, 1);
      _resizeDelay.pause();
      _refreshID++;
      _refreshingAll = 2;
      _updateAll(2);
      _triggers.forEach(function (t) {
        return _isFunction(t.vars.onRefresh) && t.vars.onRefresh(t);
      });
      _refreshingAll = ScrollTrigger$1.isRefreshing = false;
      _dispatch("refresh");
    },
    _lastScroll = 0,
    _direction = 1,
    _primary,
    _updateAll = function _updateAll(force) {
      if (!_refreshingAll || force === 2) {
        ScrollTrigger$1.isUpdating = true;
        _primary && _primary.update(0);
        var l = _triggers.length,
          time = _getTime$1(),
          recordVelocity = time - _time1 >= 50,
          scroll = l && _triggers[0].scroll();
        _direction = _lastScroll > scroll ? -1 : 1;
        _refreshingAll || (_lastScroll = scroll);
        if (recordVelocity) {
          if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
            _lastScrollTime = 0;
            _dispatch("scrollEnd");
          }
          _time2 = _time1;
          _time1 = time;
        }
        if (_direction < 0) {
          _i = l;
          while (_i-- > 0) {
            _triggers[_i] && _triggers[_i].update(0, recordVelocity);
          }
          _direction = 1;
        } else {
          for (_i = 0; _i < l; _i++) {
            _triggers[_i] && _triggers[_i].update(0, recordVelocity);
          }
        }
        ScrollTrigger$1.isUpdating = false;
      }
      _rafID = 0;
    },
    _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
    _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),
    _swapPinOut = function _swapPinOut(pin, spacer, state) {
      _setState(state);
      var cache = pin._gsap;
      if (cache.spacerIsNative) {
        _setState(cache.spacerState);
      } else if (pin._gsap.swappedIn) {
        var parent = spacer.parentNode;
        if (parent) {
          parent.insertBefore(pin, spacer);
          parent.removeChild(spacer);
        }
      }
      pin._gsap.swappedIn = false;
    },
    _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
      if (!pin._gsap.swappedIn) {
        var i = _propNamesToCopy.length,
          spacerStyle = spacer.style,
          pinStyle = pin.style,
          p;
        while (i--) {
          p = _propNamesToCopy[i];
          spacerStyle[p] = cs[p];
        }
        spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
        cs.display === "inline" && (spacerStyle.display = "inline-block");
        pinStyle[_bottom] = pinStyle[_right] = "auto";
        spacerStyle.flexBasis = cs.flexBasis || "auto";
        spacerStyle.overflow = "visible";
        spacerStyle.boxSizing = "border-box";
        spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
        spacerStyle[_height] = _getSize(pin, _vertical) + _px;
        spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";
        _setState(spacerState);
        pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
        pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
        pinStyle[_padding] = cs[_padding];
        if (pin.parentNode !== spacer) {
          pin.parentNode.insertBefore(spacer, pin);
          spacer.appendChild(pin);
        }
        pin._gsap.swappedIn = true;
      }
    },
    _capsExp = /([A-Z])/g,
    _setState = function _setState(state) {
      if (state) {
        var style = state.t.style,
          l = state.length,
          i = 0,
          p,
          value;
        (state.t._gsap || gsap$1.core.getCache(state.t)).uncache = 1;
        for (; i < l; i += 2) {
          value = state[i + 1];
          p = state[i];
          if (value) {
            style[p] = value;
          } else if (style[p]) {
            style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
          }
        }
      }
    },
    _getState = function _getState(element) {
      var l = _stateProps.length,
        style = element.style,
        state = [],
        i = 0;
      for (; i < l; i++) {
        state.push(_stateProps[i], style[_stateProps[i]]);
      }
      state.t = element;
      return state;
    },
    _copyState = function _copyState(state, override, omitOffsets) {
      var result = [],
        l = state.length,
        i = omitOffsets ? 8 : 0,
        p;
      for (; i < l; i += 2) {
        p = state[i];
        result.push(p, p in override ? override[p] : state[i + 1]);
      }
      result.t = state.t;
      return result;
    },
    _winOffsets = {
      left: 0,
      top: 0
    },
    _parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation) {
      _isFunction(value) && (value = value(self));
      if (_isString(value) && value.substr(0, 3) === "max") {
        value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
      }
      var time = containerAnimation ? containerAnimation.time() : 0,
        p1,
        p2,
        element;
      containerAnimation && containerAnimation.seek(0);
      if (!_isNumber(value)) {
        _isFunction(trigger) && (trigger = trigger(self));
        var offsets = (value || "0").split(" "),
          bounds,
          localOffset,
          globalOffset,
          display;
        element = _getTarget(trigger) || _body$1;
        bounds = _getBounds(element) || {};
        if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
          display = element.style.display;
          element.style.display = "block";
          bounds = _getBounds(element);
          display ? element.style.display = display : element.style.removeProperty("display");
        }
        localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
        globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
        value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
        markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
        scrollerSize -= scrollerSize - globalOffset;
      } else {
        containerAnimation && (value = gsap$1.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));
        markerScroller && _positionMarker(markerScroller, scrollerSize, direction, true);
      }
      if (marker) {
        var position = value + scrollerSize,
          isStart = marker._isStart;
        p1 = "scroll" + direction.d2;
        _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body$1[p1], _docEl$1[p1]) : marker.parentNode[p1]) <= position + 1);
        if (useFixedPosition) {
          scrollerBounds = _getBounds(markerScroller);
          useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
        }
      }
      if (containerAnimation && element) {
        p1 = _getBounds(element);
        containerAnimation.seek(scrollerMax);
        p2 = _getBounds(element);
        containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
        value = value / containerAnimation._caScrollDist * scrollerMax;
      }
      containerAnimation && containerAnimation.seek(time);
      return containerAnimation ? value : Math.round(value);
    },
    _prefixExp = /(webkit|moz|length|cssText|inset)/i,
    _reparent = function _reparent(element, parent, top, left) {
      if (element.parentNode !== parent) {
        var style = element.style,
          p,
          cs;
        if (parent === _body$1) {
          element._stOrig = style.cssText;
          cs = _getComputedStyle(element);
          for (p in cs) {
            if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
              style[p] = cs[p];
            }
          }
          style.top = top;
          style.left = left;
        } else {
          style.cssText = element._stOrig;
        }
        gsap$1.core.getCache(element).uncache = 1;
        parent.appendChild(element);
      }
    },
    _interruptionTracker = function _interruptionTracker(getValueFunc, initialValue, onInterrupt) {
      var last1 = initialValue,
        last2 = last1;
      return function (value) {
        var current = Math.round(getValueFunc());
        if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {
          value = current;
          onInterrupt && onInterrupt();
        }
        last2 = last1;
        last1 = value;
        return value;
      };
    },
    _getTweenCreator = function _getTweenCreator(scroller, direction) {
      var getScroll = _getScrollFunc(scroller, direction),
        prop = "_scroll" + direction.p2,
        getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {
          var tween = getTween.tween,
            onComplete = vars.onComplete,
            modifiers = {};
          initialValue = initialValue || getScroll();
          var checkForInterruption = _interruptionTracker(getScroll, initialValue, function () {
            tween.kill();
            getTween.tween = 0;
          });
          change2 = change1 && change2 || 0;
          change1 = change1 || scrollTo - initialValue;
          tween && tween.kill();
          vars[prop] = scrollTo;
          vars.modifiers = modifiers;
          modifiers[prop] = function () {
            return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio);
          };
          vars.onUpdate = function () {
            _scrollers.cache++;
            _updateAll();
          };
          vars.onComplete = function () {
            getTween.tween = 0;
            onComplete && onComplete.call(tween);
          };
          tween = getTween.tween = gsap$1.to(scroller, vars);
          return tween;
        };
      scroller[prop] = getScroll;
      getScroll.wheelHandler = function () {
        return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
      };
      _addListener$1(scroller, "wheel", getScroll.wheelHandler);
      ScrollTrigger$1.isTouch && _addListener$1(scroller, "touchmove", getScroll.wheelHandler);
      return getTween;
    };
  var ScrollTrigger$1 = function () {
    function ScrollTrigger(vars, animation) {
      _coreInitted$1 || ScrollTrigger.register(gsap$1) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
      this.init(vars, animation);
    }
    var _proto = ScrollTrigger.prototype;
    _proto.init = function init(vars, animation) {
      this.progress = this.start = 0;
      this.vars && this.kill(true, true);
      if (!_enabled) {
        this.update = this.refresh = this.kill = _passThrough;
        return;
      }
      vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {
        trigger: vars
      } : vars, _defaults);
      var _vars = vars,
        onUpdate = _vars.onUpdate,
        toggleClass = _vars.toggleClass,
        id = _vars.id,
        onToggle = _vars.onToggle,
        onRefresh = _vars.onRefresh,
        scrub = _vars.scrub,
        trigger = _vars.trigger,
        pin = _vars.pin,
        pinSpacing = _vars.pinSpacing,
        invalidateOnRefresh = _vars.invalidateOnRefresh,
        anticipatePin = _vars.anticipatePin,
        onScrubComplete = _vars.onScrubComplete,
        onSnapComplete = _vars.onSnapComplete,
        once = _vars.once,
        snap = _vars.snap,
        pinReparent = _vars.pinReparent,
        pinSpacer = _vars.pinSpacer,
        containerAnimation = _vars.containerAnimation,
        fastScrollEnd = _vars.fastScrollEnd,
        preventOverlaps = _vars.preventOverlaps,
        direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical,
        isToggle = !scrub && scrub !== 0,
        scroller = _getTarget(vars.scroller || _win$1),
        scrollerCache = gsap$1.core.getCache(scroller),
        isViewport = _isViewport$1(scroller),
        useFixedPosition = ("pinType" in vars ? vars.pinType : _getProxyProp(scroller, "pinType") || isViewport && "fixed") === "fixed",
        callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],
        toggleActions = isToggle && vars.toggleActions.split(" "),
        markers = "markers" in vars ? vars.markers : _defaults.markers,
        borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0,
        self = this,
        onRefreshInit = vars.onRefreshInit && function () {
          return vars.onRefreshInit(self);
        },
        getScrollerSize = _getSizeFunc(scroller, isViewport, direction),
        getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),
        lastSnap = 0,
        lastRefresh = 0,
        scrollFunc = _getScrollFunc(scroller, direction),
        tweenTo,
        pinCache,
        snapFunc,
        scroll1,
        scroll2,
        start,
        end,
        markerStart,
        markerEnd,
        markerStartTrigger,
        markerEndTrigger,
        markerVars,
        change,
        pinOriginalState,
        pinActiveState,
        pinState,
        spacer,
        offset,
        pinGetter,
        pinSetter,
        pinStart,
        pinChange,
        spacingStart,
        spacerState,
        markerStartSetter,
        pinMoves,
        markerEndSetter,
        cs,
        snap1,
        snap2,
        scrubTween,
        scrubSmooth,
        snapDurClamp,
        snapDelayedCall,
        prevProgress,
        prevScroll,
        prevAnimProgress,
        caMarkerSetter,
        customRevertReturn;
      _context$1(self);
      self._dir = direction;
      anticipatePin *= 45;
      self.scroller = scroller;
      self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
      scroll1 = scrollFunc();
      self.vars = vars;
      animation = animation || vars.animation;
      if ("refreshPriority" in vars) {
        _sort = 1;
        vars.refreshPriority === -9999 && (_primary = self);
      }
      scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
        top: _getTweenCreator(scroller, _vertical),
        left: _getTweenCreator(scroller, _horizontal)
      };
      self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];
      self.scrubDuration = function (value) {
        scrubSmooth = _isNumber(value) && value;
        if (!scrubSmooth) {
          scrubTween && scrubTween.progress(1).kill();
          scrubTween = 0;
        } else {
          scrubTween ? scrubTween.duration(value) : scrubTween = gsap$1.to(animation, {
            ease: "expo",
            totalProgress: "+=0.001",
            duration: scrubSmooth,
            paused: true,
            onComplete: function onComplete() {
              return onScrubComplete && onScrubComplete(self);
            }
          });
        }
      };
      if (animation) {
        animation.vars.lazy = false;
        animation._initted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true);
        self.animation = animation.pause();
        animation.scrollTrigger = self;
        self.scrubDuration(scrub);
        scrubTween && scrubTween.resetTo && scrubTween.resetTo("totalProgress", 0);
        snap1 = 0;
        id || (id = animation.vars.id);
      }
      _triggers.push(self);
      if (snap) {
        if (!_isObject(snap) || snap.push) {
          snap = {
            snapTo: snap
          };
        }
        "scrollBehavior" in _body$1.style && gsap$1.set(isViewport ? [_body$1, _docEl$1] : scroller, {
          scrollBehavior: "auto"
        });
        _scrollers.forEach(function (o) {
          return _isFunction(o) && o.target === (isViewport ? _doc$1.scrollingElement || _docEl$1 : scroller) && (o.smooth = false);
        });
        snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap.directional !== false ? function (value, st) {
          return _snapDirectional(snap.snapTo)(value, _getTime$1() - lastRefresh < 500 ? 0 : st.direction);
        } : gsap$1.utils.snap(snap.snapTo);
        snapDurClamp = snap.duration || {
          min: 0.1,
          max: 2
        };
        snapDurClamp = _isObject(snapDurClamp) ? _clamp$1(snapDurClamp.min, snapDurClamp.max) : _clamp$1(snapDurClamp, snapDurClamp);
        snapDelayedCall = gsap$1.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {
          var scroll = scrollFunc(),
            refreshedRecently = _getTime$1() - lastRefresh < 500,
            tween = tweenTo.tween;
          if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {
            var progress = (scroll - start) / change,
              totalProgress = animation && !isToggle ? animation.totalProgress() : progress,
              velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime$1() - _time2) * 1000 || 0,
              change1 = gsap$1.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185),
              naturalEnd = progress + (snap.inertia === false ? 0 : change1),
              endValue = _clamp$1(0, 1, snapFunc(naturalEnd, self)),
              endScroll = Math.round(start + endValue * change),
              _snap = snap,
              onStart = _snap.onStart,
              _onInterrupt = _snap.onInterrupt,
              _onComplete = _snap.onComplete;
            if (scroll <= end && scroll >= start && endScroll !== scroll) {
              if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {
                return;
              }
              if (snap.inertia === false) {
                change1 = endValue - progress;
              }
              tweenTo(endScroll, {
                duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
                ease: snap.ease || "power3",
                data: _abs(endScroll - scroll),
                onInterrupt: function onInterrupt() {
                  return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);
                },
                onComplete: function onComplete() {
                  self.update();
                  lastSnap = scrollFunc();
                  snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
                  onSnapComplete && onSnapComplete(self);
                  _onComplete && _onComplete(self);
                }
              }, scroll, change1 * change, endScroll - scroll - change1 * change);
              onStart && onStart(self, tweenTo.tween);
            }
          } else if (self.isActive && lastSnap !== scroll) {
            snapDelayedCall.restart(true);
          }
        }).pause();
      }
      id && (_ids[id] = self);
      trigger = self.trigger = _getTarget(trigger || pin);
      customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
      customRevertReturn && (customRevertReturn = customRevertReturn(self));
      pin = pin === true ? trigger : _getTarget(pin);
      _isString(toggleClass) && (toggleClass = {
        targets: trigger,
        className: toggleClass
      });
      if (pin) {
        pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding);
        self.pin = pin;
        pinCache = gsap$1.core.getCache(pin);
        if (!pinCache.spacer) {
          if (pinSpacer) {
            pinSpacer = _getTarget(pinSpacer);
            pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement);
            pinCache.spacerIsNative = !!pinSpacer;
            pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
          }
          pinCache.spacer = spacer = pinSpacer || _doc$1.createElement("div");
          spacer.classList.add("pin-spacer");
          id && spacer.classList.add("pin-spacer-" + id);
          pinCache.pinState = pinOriginalState = _getState(pin);
        } else {
          pinOriginalState = pinCache.pinState;
        }
        vars.force3D !== false && gsap$1.set(pin, {
          force3D: true
        });
        self.spacer = spacer = pinCache.spacer;
        cs = _getComputedStyle(pin);
        spacingStart = cs[pinSpacing + direction.os2];
        pinGetter = gsap$1.getProperty(pin);
        pinSetter = gsap$1.quickSetter(pin, direction.a, _px);
        _swapPinIn(pin, spacer, cs);
        pinState = _getState(pin);
      }
      if (markers) {
        markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;
        markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
        markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
        offset = markerStartTrigger["offset" + direction.op.d2];
        var content = _getTarget(_getProxyProp(scroller, "content") || scroller);
        markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset, 0, containerAnimation);
        markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset, 0, containerAnimation);
        containerAnimation && (caMarkerSetter = gsap$1.quickSetter([markerStart, markerEnd], direction.a, _px));
        if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
          _makePositionable(isViewport ? _body$1 : scroller);
          gsap$1.set([markerStartTrigger, markerEndTrigger], {
            force3D: true
          });
          markerStartSetter = gsap$1.quickSetter(markerStartTrigger, direction.a, _px);
          markerEndSetter = gsap$1.quickSetter(markerEndTrigger, direction.a, _px);
        }
      }
      if (containerAnimation) {
        var oldOnUpdate = containerAnimation.vars.onUpdate,
          oldParams = containerAnimation.vars.onUpdateParams;
        containerAnimation.eventCallback("onUpdate", function () {
          self.update(0, 0, 1);
          oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || []);
        });
      }
      self.previous = function () {
        return _triggers[_triggers.indexOf(self) - 1];
      };
      self.next = function () {
        return _triggers[_triggers.indexOf(self) + 1];
      };
      self.revert = function (revert, temp) {
        if (!temp) {
          return self.kill(true);
        }
        var r = revert !== false || !self.enabled,
          prevRefreshing = _refreshing;
        if (r !== self.isReverted) {
          if (r) {
            prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0);
            prevProgress = self.progress;
            prevAnimProgress = animation && animation.progress();
          }
          markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
            return m.style.display = r ? "none" : "block";
          });
          if (r) {
            _refreshing = self;
            self.update(r);
          }
          if (pin && (!pinReparent || !self.isActive)) {
            if (r) {
              _swapPinOut(pin, spacer, pinOriginalState);
            } else {
              _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);
            }
          }
          r || self.update(r);
          _refreshing = prevRefreshing;
          self.isReverted = r;
        }
      };
      self.refresh = function (soft, force) {
        if ((_refreshing || !self.enabled) && !force) {
          return;
        }
        if (pin && soft && _lastScrollTime) {
          _addListener$1(ScrollTrigger, "scrollEnd", _softRefresh);
          return;
        }
        !_refreshingAll && onRefreshInit && onRefreshInit(self);
        _refreshing = self;
        lastRefresh = _getTime$1();
        if (tweenTo.tween) {
          tweenTo.tween.kill();
          tweenTo.tween = 0;
        }
        scrubTween && scrubTween.pause();
        invalidateOnRefresh && animation && animation.revert({
          kill: false
        }).invalidate();
        self.isReverted || self.revert(true, true);
        self._subPinOffset = false;
        var size = getScrollerSize(),
          scrollerBounds = getScrollerOffsets(),
          max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction),
          isFirstRefresh = change <= 0.01,
          offset = 0,
          otherPinOffset = 0,
          parsedEnd = vars.end,
          parsedEndTrigger = vars.endTrigger || trigger,
          parsedStart = vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"),
          pinnedContainer = self.pinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer),
          triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,
          i = triggerIndex,
          cs,
          bounds,
          scroll,
          isVertical,
          override,
          curTrigger,
          curPin,
          oppositeScroll,
          initted,
          revertedPins,
          forcedOverflow;
        while (i--) {
          curTrigger = _triggers[i];
          curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self);
          curPin = curTrigger.pin;
          if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {
            revertedPins || (revertedPins = []);
            revertedPins.unshift(curTrigger);
            curTrigger.revert(true, true);
          }
          if (curTrigger !== _triggers[i]) {
            triggerIndex--;
            i--;
          }
        }
        _isFunction(parsedStart) && (parsedStart = parsedStart(self));
        start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation) || (pin ? -0.001 : 0);
        _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));
        if (_isString(parsedEnd) && !parsedEnd.indexOf("+=")) {
          if (~parsedEnd.indexOf(" ")) {
            parsedEnd = (_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
          } else {
            offset = _offsetToPx(parsedEnd.substr(2), size);
            parsedEnd = _isString(parsedStart) ? parsedStart : (containerAnimation ? gsap$1.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset;
            parsedEndTrigger = trigger;
          }
        }
        end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation)) || -0.001;
        change = end - start || (start -= 0.01) && 0.001;
        offset = 0;
        i = triggerIndex;
        while (i--) {
          curTrigger = _triggers[i];
          curPin = curTrigger.pin;
          if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {
            cs = curTrigger.end - curTrigger.start;
            if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && !_isNumber(parsedStart)) {
              offset += cs * (1 - curTrigger.progress);
            }
            curPin === pin && (otherPinOffset += cs);
          }
        }
        start += offset;
        end += offset;
        if (isFirstRefresh) {
          prevProgress = gsap$1.utils.clamp(0, 1, gsap$1.utils.normalize(start, end, prevScroll));
        }
        self._pinPush = otherPinOffset;
        if (markerStart && offset) {
          cs = {};
          cs[direction.a] = "+=" + offset;
          pinnedContainer && (cs[direction.p] = "-=" + scrollFunc());
          gsap$1.set([markerStart, markerEnd], cs);
        }
        if (pin) {
          cs = _getComputedStyle(pin);
          isVertical = direction === _vertical;
          scroll = scrollFunc();
          pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
          if (!max && end > 1) {
            forcedOverflow = (isViewport ? _doc$1.scrollingElement || _docEl$1 : scroller).style;
            forcedOverflow = {
              style: forcedOverflow,
              value: forcedOverflow["overflow" + direction.a.toUpperCase()]
            };
            forcedOverflow.style["overflow" + direction.a.toUpperCase()] = "scroll";
          }
          _swapPinIn(pin, spacer, cs);
          pinState = _getState(pin);
          bounds = _getBounds(pin, true);
          oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();
          if (pinSpacing) {
            spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
            spacerState.t = spacer;
            i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
            i && spacerState.push(direction.d, i + _px);
            _setState(spacerState);
            if (pinnedContainer) {
              _triggers.forEach(function (t) {
                if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) {
                  t._subPinOffset = true;
                }
              });
            }
            useFixedPosition && scrollFunc(prevScroll);
          }
          if (useFixedPosition) {
            override = {
              top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
              left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
              boxSizing: "border-box",
              position: "fixed"
            };
            override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
            override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
            override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
            override[_padding] = cs[_padding];
            override[_padding + _Top] = cs[_padding + _Top];
            override[_padding + _Right] = cs[_padding + _Right];
            override[_padding + _Bottom] = cs[_padding + _Bottom];
            override[_padding + _Left] = cs[_padding + _Left];
            pinActiveState = _copyState(pinOriginalState, override, pinReparent);
            _refreshingAll && scrollFunc(0);
          }
          if (animation) {
            initted = animation._initted;
            _suppressOverwrites(1);
            animation.render(animation.duration(), true, true);
            pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
            pinMoves = Math.abs(change - pinChange) > 1;
            useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2);
            animation.render(0, true, true);
            initted || animation.invalidate(true);
            animation.parent || animation.totalTime(animation.totalTime());
            _suppressOverwrites(0);
          } else {
            pinChange = change;
          }
          forcedOverflow && (forcedOverflow.value ? forcedOverflow.style["overflow" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty("overflow-" + direction.a));
        } else if (trigger && scrollFunc() && !containerAnimation) {
          bounds = trigger.parentNode;
          while (bounds && bounds !== _body$1) {
            if (bounds._pinOffset) {
              start -= bounds._pinOffset;
              end -= bounds._pinOffset;
            }
            bounds = bounds.parentNode;
          }
        }
        revertedPins && revertedPins.forEach(function (t) {
          return t.revert(false, true);
        });
        self.start = start;
        self.end = end;
        scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc();
        if (!containerAnimation && !_refreshingAll) {
          scroll1 < prevScroll && scrollFunc(prevScroll);
          self.scroll.rec = 0;
        }
        self.revert(false, true);
        if (snapDelayedCall) {
          lastSnap = -1;
          self.isActive && scrollFunc(start + change * prevProgress);
          snapDelayedCall.restart(true);
        }
        _refreshing = 0;
        animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress, true).render(animation.time(), true, true);
        if (isFirstRefresh || prevProgress !== self.progress || containerAnimation) {
          animation && !isToggle && animation.totalProgress(containerAnimation && start < -0.001 && !prevProgress ? gsap$1.utils.normalize(start, end, 0) : prevProgress, true);
          self.progress = (scroll1 - start) / change === prevProgress ? 0 : prevProgress;
        }
        pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));
        scrubTween && scrubTween.invalidate();
        onRefresh && !_refreshingAll && onRefresh(self);
      };
      self.getVelocity = function () {
        return (scrollFunc() - scroll2) / (_getTime$1() - _time2) * 1000 || 0;
      };
      self.endAnimation = function () {
        _endAnimation(self.callbackAnimation);
        if (animation) {
          scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);
        }
      };
      self.labelToScroll = function (label) {
        return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
      };
      self.getTrailing = function (name) {
        var i = _triggers.indexOf(self),
          a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);
        return (_isString(name) ? a.filter(function (t) {
          return t.vars.preventOverlaps === name;
        }) : a).filter(function (t) {
          return self.direction > 0 ? t.end <= start : t.start >= end;
        });
      };
      self.update = function (reset, recordVelocity, forceFake) {
        if (containerAnimation && !forceFake && !reset) {
          return;
        }
        var scroll = _refreshingAll === true ? prevScroll : self.scroll(),
          p = reset ? 0 : (scroll - start) / change,
          clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
          prevProgress = self.progress,
          isActive,
          wasActive,
          toggleState,
          action,
          stateChanged,
          toggled,
          isAtMax,
          isTakingAction;
        if (recordVelocity) {
          scroll2 = scroll1;
          scroll1 = containerAnimation ? scrollFunc() : scroll;
          if (snap) {
            snap2 = snap1;
            snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
          }
        }
        anticipatePin && !clipped && pin && !_refreshing && !_startup$1 && _lastScrollTime && start < scroll + (scroll - scroll2) / (_getTime$1() - _time2) * anticipatePin && (clipped = 0.0001);
        if (clipped !== prevProgress && self.enabled) {
          isActive = self.isActive = !!clipped && clipped < 1;
          wasActive = !!prevProgress && prevProgress < 1;
          toggled = isActive !== wasActive;
          stateChanged = toggled || !!clipped !== !!prevProgress;
          self.direction = clipped > prevProgress ? 1 : -1;
          self.progress = clipped;
          if (stateChanged && !_refreshing) {
            toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3;
            if (isToggle) {
              action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState];
              isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
            }
          }
          preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function (t) {
            return t.endAnimation();
          }));
          if (!isToggle) {
            if (scrubTween && !_refreshing && !_startup$1) {
              scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start);
              if (scrubTween.resetTo) {
                scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur);
              } else {
                scrubTween.vars.totalProgress = clipped;
                scrubTween.invalidate().restart();
              }
            } else if (animation) {
              animation.totalProgress(clipped, !!_refreshing);
            }
          }
          if (pin) {
            reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);
            if (!useFixedPosition) {
              pinSetter(_round(pinStart + pinChange * clipped));
            } else if (stateChanged) {
              isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction);
              if (pinReparent) {
                if (!reset && (isActive || isAtMax)) {
                  var bounds = _getBounds(pin, true),
                    _offset = scroll - start;
                  _reparent(pin, _body$1, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);
                } else {
                  _reparent(pin, spacer);
                }
              }
              _setState(isActive || isAtMax ? pinActiveState : pinState);
              pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
            }
          }
          snap && !tweenTo.tween && !_refreshing && !_startup$1 && snapDelayedCall.restart(true);
          toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function (el) {
            return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
          });
          onUpdate && !isToggle && !reset && onUpdate(self);
          if (stateChanged && !_refreshing) {
            if (isToggle) {
              if (isTakingAction) {
                if (action === "complete") {
                  animation.pause().totalProgress(1);
                } else if (action === "reset") {
                  animation.restart(true).pause();
                } else if (action === "restart") {
                  animation.restart(true);
                } else {
                  animation[action]();
                }
              }
              onUpdate && onUpdate(self);
            }
            if (toggled || !_limitCallbacks) {
              onToggle && toggled && _callback(self, onToggle);
              callbacks[toggleState] && _callback(self, callbacks[toggleState]);
              once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0);
              if (!toggled) {
                toggleState = clipped === 1 ? 1 : 3;
                callbacks[toggleState] && _callback(self, callbacks[toggleState]);
              }
            }
            if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {
              _endAnimation(self.callbackAnimation);
              scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === "reverse" ? 1 : !clipped, 1);
            }
          } else if (isToggle && onUpdate && !_refreshing) {
            onUpdate(self);
          }
        }
        if (markerEndSetter) {
          var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
          markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
          markerEndSetter(n);
        }
        caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
      };
      self.enable = function (reset, refresh) {
        if (!self.enabled) {
          self.enabled = true;
          _addListener$1(scroller, "resize", _onResize);
          _addListener$1(isViewport ? _doc$1 : scroller, "scroll", _onScroll$1);
          onRefreshInit && _addListener$1(ScrollTrigger, "refreshInit", onRefreshInit);
          if (reset !== false) {
            self.progress = prevProgress = 0;
            scroll1 = scroll2 = lastSnap = scrollFunc();
          }
          refresh !== false && self.refresh();
        }
      };
      self.getTween = function (snap) {
        return snap && tweenTo ? tweenTo.tween : scrubTween;
      };
      self.setPositions = function (newStart, newEnd) {
        if (pin) {
          pinStart += newStart - start;
          pinChange += newEnd - newStart - change;
          pinSpacing === _padding && self.adjustPinSpacing(newEnd - newStart - change);
        }
        self.start = start = newStart;
        self.end = end = newEnd;
        change = newEnd - newStart;
        self.update();
      };
      self.adjustPinSpacing = function (amount) {
        if (spacerState && amount) {
          var i = spacerState.indexOf(direction.d) + 1;
          spacerState[i] = parseFloat(spacerState[i]) + amount + _px;
          spacerState[1] = parseFloat(spacerState[1]) + amount + _px;
          _setState(spacerState);
        }
      };
      self.disable = function (reset, allowAnimation) {
        if (self.enabled) {
          reset !== false && self.revert(true, true);
          self.enabled = self.isActive = false;
          allowAnimation || scrubTween && scrubTween.pause();
          prevScroll = 0;
          pinCache && (pinCache.uncache = 1);
          onRefreshInit && _removeListener$1(ScrollTrigger, "refreshInit", onRefreshInit);
          if (snapDelayedCall) {
            snapDelayedCall.pause();
            tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
          }
          if (!isViewport) {
            var i = _triggers.length;
            while (i--) {
              if (_triggers[i].scroller === scroller && _triggers[i] !== self) {
                return;
              }
            }
            _removeListener$1(scroller, "resize", _onResize);
            _removeListener$1(scroller, "scroll", _onScroll$1);
          }
        }
      };
      self.kill = function (revert, allowAnimation) {
        self.disable(revert, allowAnimation);
        scrubTween && !allowAnimation && scrubTween.kill();
        id && delete _ids[id];
        var i = _triggers.indexOf(self);
        i >= 0 && _triggers.splice(i, 1);
        i === _i && _direction > 0 && _i--;
        i = 0;
        _triggers.forEach(function (t) {
          return t.scroller === self.scroller && (i = 1);
        });
        i || _refreshingAll || (self.scroll.rec = 0);
        if (animation) {
          animation.scrollTrigger = null;
          revert && animation.revert({
            kill: false
          });
          allowAnimation || animation.kill();
        }
        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
          return m.parentNode && m.parentNode.removeChild(m);
        });
        _primary === self && (_primary = 0);
        if (pin) {
          pinCache && (pinCache.uncache = 1);
          i = 0;
          _triggers.forEach(function (t) {
            return t.pin === pin && i++;
          });
          i || (pinCache.spacer = 0);
        }
        vars.onKill && vars.onKill(self);
      };
      self.enable(false, false);
      customRevertReturn && customRevertReturn(self);
      !animation || !animation.add || change ? self.refresh() : gsap$1.delayedCall(0.01, function () {
        return start || end || self.refresh();
      }) && (change = 0.01) && (start = end = 0);
      pin && _queueRefreshAll();
    };
    ScrollTrigger.register = function register(core) {
      if (!_coreInitted$1) {
        gsap$1 = core || _getGSAP$1();
        _windowExists() && window.document && ScrollTrigger.enable();
        _coreInitted$1 = _enabled;
      }
      return _coreInitted$1;
    };
    ScrollTrigger.defaults = function defaults(config) {
      if (config) {
        for (var p in config) {
          _defaults[p] = config[p];
        }
      }
      return _defaults;
    };
    ScrollTrigger.disable = function disable(reset, kill) {
      _enabled = 0;
      _triggers.forEach(function (trigger) {
        return trigger[kill ? "kill" : "disable"](reset);
      });
      _removeListener$1(_win$1, "wheel", _onScroll$1);
      _removeListener$1(_doc$1, "scroll", _onScroll$1);
      clearInterval(_syncInterval);
      _removeListener$1(_doc$1, "touchcancel", _passThrough);
      _removeListener$1(_body$1, "touchstart", _passThrough);
      _multiListener(_removeListener$1, _doc$1, "pointerdown,touchstart,mousedown", _pointerDownHandler);
      _multiListener(_removeListener$1, _doc$1, "pointerup,touchend,mouseup", _pointerUpHandler);
      _resizeDelay.kill();
      _iterateAutoRefresh(_removeListener$1);
      for (var i = 0; i < _scrollers.length; i += 3) {
        _wheelListener(_removeListener$1, _scrollers[i], _scrollers[i + 1]);
        _wheelListener(_removeListener$1, _scrollers[i], _scrollers[i + 2]);
      }
    };
    ScrollTrigger.enable = function enable() {
      _win$1 = window;
      _doc$1 = document;
      _docEl$1 = _doc$1.documentElement;
      _body$1 = _doc$1.body;
      if (gsap$1) {
        _toArray = gsap$1.utils.toArray;
        _clamp$1 = gsap$1.utils.clamp;
        _context$1 = gsap$1.core.context || _passThrough;
        _suppressOverwrites = gsap$1.core.suppressOverwrites || _passThrough;
        _scrollRestoration = _win$1.history.scrollRestoration || "auto";
        _lastScroll = _win$1.pageYOffset;
        gsap$1.core.globals("ScrollTrigger", ScrollTrigger);
        if (_body$1) {
          _enabled = 1;
          _rafBugFix();
          Observer.register(gsap$1);
          ScrollTrigger.isTouch = Observer.isTouch;
          _fixIOSBug = Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent);
          _addListener$1(_win$1, "wheel", _onScroll$1);
          _root$1 = [_win$1, _doc$1, _docEl$1, _body$1];
          if (gsap$1.matchMedia) {
            ScrollTrigger.matchMedia = function (vars) {
              var mm = gsap$1.matchMedia(),
                p;
              for (p in vars) {
                mm.add(p, vars[p]);
              }
              return mm;
            };
            gsap$1.addEventListener("matchMediaInit", function () {
              return _revertAll();
            });
            gsap$1.addEventListener("matchMediaRevert", function () {
              return _revertRecorded();
            });
            gsap$1.addEventListener("matchMedia", function () {
              _refreshAll(0, 1);
              _dispatch("matchMedia");
            });
            gsap$1.matchMedia("(orientation: portrait)", function () {
              _setBaseDimensions();
              return _setBaseDimensions;
            });
          } else {
            console.warn("Requires GSAP 3.11.0 or later");
          }
          _setBaseDimensions();
          _addListener$1(_doc$1, "scroll", _onScroll$1);
          var bodyStyle = _body$1.style,
            border = bodyStyle.borderTopStyle,
            AnimationProto = gsap$1.core.Animation.prototype,
            bounds,
            i;
          AnimationProto.revert || Object.defineProperty(AnimationProto, "revert", {
            value: function value() {
              return this.time(-0.01, true);
            }
          });
          bodyStyle.borderTopStyle = "solid";
          bounds = _getBounds(_body$1);
          _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0;
          _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
          border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style");
          _syncInterval = setInterval(_sync, 250);
          gsap$1.delayedCall(0.5, function () {
            return _startup$1 = 0;
          });
          _addListener$1(_doc$1, "touchcancel", _passThrough);
          _addListener$1(_body$1, "touchstart", _passThrough);
          _multiListener(_addListener$1, _doc$1, "pointerdown,touchstart,mousedown", _pointerDownHandler);
          _multiListener(_addListener$1, _doc$1, "pointerup,touchend,mouseup", _pointerUpHandler);
          _transformProp = gsap$1.utils.checkPrefix("transform");
          _stateProps.push(_transformProp);
          _coreInitted$1 = _getTime$1();
          _resizeDelay = gsap$1.delayedCall(0.2, _refreshAll).pause();
          _autoRefresh = [_doc$1, "visibilitychange", function () {
            var w = _win$1.innerWidth,
              h = _win$1.innerHeight;
            if (_doc$1.hidden) {
              _prevWidth = w;
              _prevHeight = h;
            } else if (_prevWidth !== w || _prevHeight !== h) {
              _onResize();
            }
          }, _doc$1, "DOMContentLoaded", _refreshAll, _win$1, "load", _refreshAll, _win$1, "resize", _onResize];
          _iterateAutoRefresh(_addListener$1);
          _triggers.forEach(function (trigger) {
            return trigger.enable(0, 1);
          });
          for (i = 0; i < _scrollers.length; i += 3) {
            _wheelListener(_removeListener$1, _scrollers[i], _scrollers[i + 1]);
            _wheelListener(_removeListener$1, _scrollers[i], _scrollers[i + 2]);
          }
        }
      }
    };
    ScrollTrigger.config = function config(vars) {
      "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
      var ms = vars.syncInterval;
      ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
      "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);
      if ("autoRefreshEvents" in vars) {
        _iterateAutoRefresh(_removeListener$1) || _iterateAutoRefresh(_addListener$1, vars.autoRefreshEvents || "none");
        _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
      }
    };
    ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {
      var t = _getTarget(target),
        i = _scrollers.indexOf(t),
        isViewport = _isViewport$1(t);
      if (~i) {
        _scrollers.splice(i, isViewport ? 6 : 2);
      }
      if (vars) {
        isViewport ? _proxies.unshift(_win$1, vars, _body$1, vars, _docEl$1, vars) : _proxies.unshift(t, vars);
      }
    };
    ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {
      _triggers.forEach(function (t) {
        return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);
      });
    };
    ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {
      var bounds = (_isString(element) ? _getTarget(element) : element).getBoundingClientRect(),
        offset = bounds[horizontal ? _width : _height] * ratio || 0;
      return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win$1.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win$1.innerHeight;
    };
    ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
      _isString(element) && (element = _getTarget(element));
      var bounds = element.getBoundingClientRect(),
        size = bounds[horizontal ? _width : _height],
        offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
      return horizontal ? (bounds.left + offset) / _win$1.innerWidth : (bounds.top + offset) / _win$1.innerHeight;
    };
    ScrollTrigger.killAll = function killAll(allowListeners) {
      _triggers.slice(0).forEach(function (t) {
        return t.vars.id !== "ScrollSmoother" && t.kill();
      });
      if (allowListeners !== true) {
        var listeners = _listeners.killAll || [];
        _listeners = {};
        listeners.forEach(function (f) {
          return f();
        });
      }
    };
    return ScrollTrigger;
  }();
  ScrollTrigger$1.version = "3.11.5";
  ScrollTrigger$1.saveStyles = function (targets) {
    return targets ? _toArray(targets).forEach(function (target) {
      if (target && target.style) {
        var i = _savedStyles.indexOf(target);
        i >= 0 && _savedStyles.splice(i, 5);
        _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap$1.core.getCache(target), _context$1());
      }
    }) : _savedStyles;
  };
  ScrollTrigger$1.revert = function (soft, media) {
    return _revertAll(!soft, media);
  };
  ScrollTrigger$1.create = function (vars, animation) {
    return new ScrollTrigger$1(vars, animation);
  };
  ScrollTrigger$1.refresh = function (safe) {
    return safe ? _onResize() : (_coreInitted$1 || ScrollTrigger$1.register()) && _refreshAll(true);
  };
  ScrollTrigger$1.update = function (force) {
    return ++_scrollers.cache && _updateAll(force === true ? 2 : 0);
  };
  ScrollTrigger$1.clearScrollMemory = _clearScrollMemory;
  ScrollTrigger$1.maxScroll = function (element, horizontal) {
    return _maxScroll(element, horizontal ? _horizontal : _vertical);
  };
  ScrollTrigger$1.getScrollFunc = function (element, horizontal) {
    return _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);
  };
  ScrollTrigger$1.getById = function (id) {
    return _ids[id];
  };
  ScrollTrigger$1.getAll = function () {
    return _triggers.filter(function (t) {
      return t.vars.id !== "ScrollSmoother";
    });
  };
  ScrollTrigger$1.isScrolling = function () {
    return !!_lastScrollTime;
  };
  ScrollTrigger$1.snapDirectional = _snapDirectional;
  ScrollTrigger$1.addEventListener = function (type, callback) {
    var a = _listeners[type] || (_listeners[type] = []);
    ~a.indexOf(callback) || a.push(callback);
  };
  ScrollTrigger$1.removeEventListener = function (type, callback) {
    var a = _listeners[type],
      i = a && a.indexOf(callback);
    i >= 0 && a.splice(i, 1);
  };
  ScrollTrigger$1.batch = function (targets, vars) {
    var result = [],
      varsCopy = {},
      interval = vars.interval || 0.016,
      batchMax = vars.batchMax || 1e9,
      proxyCallback = function proxyCallback(type, callback) {
        var elements = [],
          triggers = [],
          delay = gsap$1.delayedCall(interval, function () {
            callback(elements, triggers);
            elements = [];
            triggers = [];
          }).pause();
        return function (self) {
          elements.length || delay.restart(true);
          elements.push(self.trigger);
          triggers.push(self);
          batchMax <= elements.length && delay.progress(1);
        };
      },
      p;
    for (p in vars) {
      varsCopy[p] = p.substr(0, 2) === "on" && _isFunction(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
    }
    if (_isFunction(batchMax)) {
      batchMax = batchMax();
      _addListener$1(ScrollTrigger$1, "refresh", function () {
        return batchMax = vars.batchMax();
      });
    }
    _toArray(targets).forEach(function (target) {
      var config = {};
      for (p in varsCopy) {
        config[p] = varsCopy[p];
      }
      config.trigger = target;
      result.push(ScrollTrigger$1.create(config));
    });
    return result;
  };
  var _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {
      current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);
      return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;
    },
    _allowNativePanning = function _allowNativePanning(target, direction) {
      if (direction === true) {
        target.style.removeProperty("touch-action");
      } else {
        target.style.touchAction = direction === true ? "auto" : direction ? "pan-" + direction + (Observer.isTouch ? " pinch-zoom" : "") : "none";
      }
      target === _docEl$1 && _allowNativePanning(_body$1, direction);
    },
    _overflow = {
      auto: 1,
      scroll: 1
    },
    _nestedScroll = function _nestedScroll(_ref5) {
      var event = _ref5.event,
        target = _ref5.target,
        axis = _ref5.axis;
      var node = (event.changedTouches ? event.changedTouches[0] : event).target,
        cache = node._gsap || gsap$1.core.getCache(node),
        time = _getTime$1(),
        cs;
      if (!cache._isScrollT || time - cache._isScrollT > 2000) {
        while (node && node !== _body$1 && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))) {
          node = node.parentNode;
        }
        cache._isScroll = node && node !== target && !_isViewport$1(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
        cache._isScrollT = time;
      }
      if (cache._isScroll || axis === "x") {
        event.stopPropagation();
        event._gsapAllow = true;
      }
    },
    _inputObserver = function _inputObserver(target, type, inputs, nested) {
      return Observer.create({
        target: target,
        capture: true,
        debounce: false,
        lockAxis: true,
        type: type,
        onWheel: nested = nested && _nestedScroll,
        onPress: nested,
        onDrag: nested,
        onScroll: nested,
        onEnable: function onEnable() {
          return inputs && _addListener$1(_doc$1, Observer.eventTypes[0], _captureInputs, false, true);
        },
        onDisable: function onDisable() {
          return _removeListener$1(_doc$1, Observer.eventTypes[0], _captureInputs, true);
        }
      });
    },
    _inputExp = /(input|label|select|textarea)/i,
    _inputIsFocused,
    _captureInputs = function _captureInputs(e) {
      var isInput = _inputExp.test(e.target.tagName);
      if (isInput || _inputIsFocused) {
        e._gsapAllow = true;
        _inputIsFocused = isInput;
      }
    },
    _getScrollNormalizer = function _getScrollNormalizer(vars) {
      _isObject(vars) || (vars = {});
      vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;
      vars.type || (vars.type = "wheel,touch");
      vars.debounce = !!vars.debounce;
      vars.id = vars.id || "normalizer";
      var _vars2 = vars,
        normalizeScrollX = _vars2.normalizeScrollX,
        momentum = _vars2.momentum,
        allowNestedScroll = _vars2.allowNestedScroll,
        onRelease = _vars2.onRelease,
        self,
        maxY,
        target = _getTarget(vars.target) || _docEl$1,
        smoother = gsap$1.core.globals().ScrollSmoother,
        smootherInstance = smoother && smoother.get(),
        content = _fixIOSBug && (vars.content && _getTarget(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()),
        scrollFuncY = _getScrollFunc(target, _vertical),
        scrollFuncX = _getScrollFunc(target, _horizontal),
        scale = 1,
        initialScale = (Observer.isTouch && _win$1.visualViewport ? _win$1.visualViewport.scale * _win$1.visualViewport.width : _win$1.outerWidth) / _win$1.innerWidth,
        wheelRefresh = 0,
        resolveMomentumDuration = _isFunction(momentum) ? function () {
          return momentum(self);
        } : function () {
          return momentum || 2.8;
        },
        lastRefreshID,
        skipTouchMove,
        inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll),
        resumeTouchMove = function resumeTouchMove() {
          return skipTouchMove = false;
        },
        scrollClampX = _passThrough,
        scrollClampY = _passThrough,
        updateClamps = function updateClamps() {
          maxY = _maxScroll(target, _vertical);
          scrollClampY = _clamp$1(_fixIOSBug ? 1 : 0, maxY);
          normalizeScrollX && (scrollClampX = _clamp$1(0, _maxScroll(target, _horizontal)));
          lastRefreshID = _refreshID;
        },
        removeContentOffset = function removeContentOffset() {
          content._gsap.y = _round(parseFloat(content._gsap.y) + scrollFuncY.offset) + "px";
          content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(content._gsap.y) + ", 0, 1)";
          scrollFuncY.offset = scrollFuncY.cacheID = 0;
        },
        ignoreDrag = function ignoreDrag() {
          if (skipTouchMove) {
            requestAnimationFrame(resumeTouchMove);
            var offset = _round(self.deltaY / 2),
              scroll = scrollClampY(scrollFuncY.v - offset);
            if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
              scrollFuncY.offset = scroll - scrollFuncY.v;
              var y = _round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);
              content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + y + ", 0, 1)";
              content._gsap.y = y + "px";
              scrollFuncY.cacheID = _scrollers.cache;
              _updateAll();
            }
            return true;
          }
          scrollFuncY.offset && removeContentOffset();
          skipTouchMove = true;
        },
        tween,
        startScrollX,
        startScrollY,
        onStopDelayedCall,
        onResize = function onResize() {
          updateClamps();
          if (tween.isActive() && tween.vars.scrollY > maxY) {
            scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY);
          }
        };
      content && gsap$1.set(content, {
        y: "+=0"
      });
      vars.ignoreCheck = function (e) {
        return _fixIOSBug && e.type === "touchmove" && ignoreDrag() || scale > 1.05 && e.type !== "touchstart" || self.isGesturing || e.touches && e.touches.length > 1;
      };
      vars.onPress = function () {
        skipTouchMove = false;
        var prevScale = scale;
        scale = _round((_win$1.visualViewport && _win$1.visualViewport.scale || 1) / initialScale);
        tween.pause();
        prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : "x");
        startScrollX = scrollFuncX();
        startScrollY = scrollFuncY();
        updateClamps();
        lastRefreshID = _refreshID;
      };
      vars.onRelease = vars.onGestureStart = function (self, wasDragging) {
        scrollFuncY.offset && removeContentOffset();
        if (!wasDragging) {
          onStopDelayedCall.restart(true);
        } else {
          _scrollers.cache++;
          var dur = resolveMomentumDuration(),
            currentScroll,
            endScroll;
          if (normalizeScrollX) {
            currentScroll = scrollFuncX();
            endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227;
            dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _horizontal));
            tween.vars.scrollX = scrollClampX(endScroll);
          }
          currentScroll = scrollFuncY();
          endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227;
          dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _vertical));
          tween.vars.scrollY = scrollClampY(endScroll);
          tween.invalidate().duration(dur).play(0.01);
          if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {
            gsap$1.to({}, {
              onUpdate: onResize,
              duration: dur
            });
          }
        }
        onRelease && onRelease(self);
      };
      vars.onWheel = function () {
        tween._ts && tween.pause();
        if (_getTime$1() - wheelRefresh > 1000) {
          lastRefreshID = 0;
          wheelRefresh = _getTime$1();
        }
      };
      vars.onChange = function (self, dx, dy, xArray, yArray) {
        _refreshID !== lastRefreshID && updateClamps();
        dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1]));
        if (dy) {
          scrollFuncY.offset && removeContentOffset();
          var isTouch = yArray[2] === dy,
            y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1],
            yClamped = scrollClampY(y);
          isTouch && y !== yClamped && (startScrollY += yClamped - y);
          scrollFuncY(yClamped);
        }
        (dy || dx) && _updateAll();
      };
      vars.onEnable = function () {
        _allowNativePanning(target, normalizeScrollX ? false : "x");
        ScrollTrigger$1.addEventListener("refresh", onResize);
        _addListener$1(_win$1, "resize", onResize);
        if (scrollFuncY.smooth) {
          scrollFuncY.target.style.scrollBehavior = "auto";
          scrollFuncY.smooth = scrollFuncX.smooth = false;
        }
        inputObserver.enable();
      };
      vars.onDisable = function () {
        _allowNativePanning(target, true);
        _removeListener$1(_win$1, "resize", onResize);
        ScrollTrigger$1.removeEventListener("refresh", onResize);
        inputObserver.kill();
      };
      vars.lockAxis = vars.lockAxis !== false;
      self = new Observer(vars);
      self.iOS = _fixIOSBug;
      _fixIOSBug && !scrollFuncY() && scrollFuncY(1);
      _fixIOSBug && gsap$1.ticker.add(_passThrough);
      onStopDelayedCall = self._dc;
      tween = gsap$1.to(self, {
        ease: "power4",
        paused: true,
        scrollX: normalizeScrollX ? "+=0.1" : "+=0",
        scrollY: "+=0.1",
        modifiers: {
          scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), function () {
            return tween.pause();
          })
        },
        onUpdate: _updateAll,
        onComplete: onStopDelayedCall.vars.onComplete
      });
      return self;
    };
  ScrollTrigger$1.sort = function (func) {
    return _triggers.sort(func || function (a, b) {
      return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);
    });
  };
  ScrollTrigger$1.observe = function (vars) {
    return new Observer(vars);
  };
  ScrollTrigger$1.normalizeScroll = function (vars) {
    if (typeof vars === "undefined") {
      return _normalizer$1;
    }
    if (vars === true && _normalizer$1) {
      return _normalizer$1.enable();
    }
    if (vars === false) {
      return _normalizer$1 && _normalizer$1.kill();
    }
    var normalizer = vars instanceof Observer ? vars : _getScrollNormalizer(vars);
    _normalizer$1 && _normalizer$1.target === normalizer.target && _normalizer$1.kill();
    _isViewport$1(normalizer.target) && (_normalizer$1 = normalizer);
    return normalizer;
  };
  ScrollTrigger$1.core = {
    _getVelocityProp: _getVelocityProp,
    _inputObserver: _inputObserver,
    _scrollers: _scrollers,
    _proxies: _proxies,
    bridge: {
      ss: function ss() {
        _lastScrollTime || _dispatch("scrollStart");
        _lastScrollTime = _getTime$1();
      },
      ref: function ref() {
        return _refreshing;
      }
    }
  };
  _getGSAP$1() && gsap$1.registerPlugin(ScrollTrigger$1);
  exports.ScrollTrigger = ScrollTrigger$1;
  exports.default = ScrollTrigger$1;
  if (typeof window === 'undefined' || window !== exports) {
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
  } else {
    delete window.default;
  }
});

},{}],34:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.Splitting = factory();
})(void 0, function () {
  'use strict';

  var root = document;
  var createText = root.createTextNode.bind(root);

  /**
   * # setProperty
   * Apply a CSS var
   * @param {HTMLElement} el
   * @param {string} varName 
   * @param {string|number} value 
   */
  function setProperty(el, varName, value) {
    el.style.setProperty(varName, value);
  }

  /**
   * 
   * @param {!HTMLElement} el 
   * @param {!HTMLElement} child 
   */
  function appendChild(el, child) {
    return el.appendChild(child);
  }

  /**
   * 
   * @param {!HTMLElement} parent 
   * @param {string} key 
   * @param {string} text 
   * @param {boolean} whitespace 
   */
  function createElement(parent, key, text, whitespace) {
    var el = root.createElement('span');
    key && (el.className = key);
    if (text) {
      !whitespace && el.setAttribute("data-" + key, text);
      el.textContent = text;
    }
    return parent && appendChild(parent, el) || el;
  }

  /**
   * 
   * @param {!HTMLElement} el 
   * @param {string} key 
   */
  function getData(el, key) {
    return el.getAttribute("data-" + key);
  }

  /**
   * 
   * @param {import('../types').Target} e 
   * @param {!HTMLElement} parent
   * @returns {!Array<!HTMLElement>}
   */
  function $(e, parent) {
    return !e || e.length == 0 ?
    // null or empty string returns empty array
    [] : e.nodeName ?
    // a single element is wrapped in an array
    [e] :
    // selector and NodeList are converted to Element[]
    [].slice.call(e[0].nodeName ? e : (parent || root).querySelectorAll(e));
  }

  /**
   * Creates and fills an array with the value provided
   * @param {number} len
   * @param {() => T} valueProvider
   * @return {T}
   * @template T
   */
  function Array2D(len) {
    var a = [];
    for (; len--;) {
      a[len] = [];
    }
    return a;
  }

  /**
   * A for loop wrapper used to reduce js minified size.
   * @param {!Array<T>} items 
   * @param {function(T):void} consumer
   * @template T
   */
  function each(items, consumer) {
    items && items.some(consumer);
  }

  /**
   * @param {T} obj 
   * @return {function(string):*}
   * @template T
   */
  function selectFrom(obj) {
    return function (key) {
      return obj[key];
    };
  }

  /**
   * # Splitting.index
   * Index split elements and add them to a Splitting instance.
   *
   * @param {HTMLElement} element
   * @param {string} key 
   * @param {!Array<!HTMLElement> | !Array<!Array<!HTMLElement>>} items 
   */
  function index(element, key, items) {
    var prefix = '--' + key;
    var cssVar = prefix + "-index";
    each(items, function (items, i) {
      if (Array.isArray(items)) {
        each(items, function (item) {
          setProperty(item, cssVar, i);
        });
      } else {
        setProperty(items, cssVar, i);
      }
    });
    setProperty(element, prefix + "-total", items.length);
  }

  /**
   * @type {Record<string, import('./types').ISplittingPlugin>}
   */
  var plugins = {};

  /**
   * @param {string} by
   * @param {string} parent
   * @param {!Array<string>} deps
   * @return {!Array<string>}
   */
  function resolvePlugins(by, parent, deps) {
    // skip if already visited this dependency
    var index = deps.indexOf(by);
    if (index == -1) {
      // if new to dependency array, add to the beginning
      deps.unshift(by);

      // recursively call this function for all dependencies
      var plugin = plugins[by];
      if (!plugin) {
        throw new Error("plugin not loaded: " + by);
      }
      each(plugin.depends, function (p) {
        resolvePlugins(p, by, deps);
      });
    } else {
      // if this dependency was added already move to the left of
      // the parent dependency so it gets loaded in order
      var indexOfParent = deps.indexOf(parent);
      deps.splice(index, 1);
      deps.splice(indexOfParent, 0, by);
    }
    return deps;
  }

  /**
   * Internal utility for creating plugins... essentially to reduce
   * the size of the library
   * @param {string} by 
   * @param {string} key 
   * @param {string[]} depends 
   * @param {Function} split 
   * @returns {import('./types').ISplittingPlugin}
   */
  function createPlugin(by, depends, key, split) {
    return {
      by: by,
      depends: depends,
      key: key,
      split: split
    };
  }

  /**
   *
   * @param {string} by
   * @returns {import('./types').ISplittingPlugin[]}
   */
  function resolve(by) {
    return resolvePlugins(by, 0, []).map(selectFrom(plugins));
  }

  /**
   * Adds a new plugin to splitting
   * @param {import('./types').ISplittingPlugin} opts
   */
  function add(opts) {
    plugins[opts.by] = opts;
  }

  /**
   * # Splitting.split
   * Split an element's textContent into individual elements
   * @param {!HTMLElement} el  Element to split
   * @param {string} key 
   * @param {string} splitOn 
   * @param {boolean} includePrevious 
   * @param {boolean} preserveWhitespace
   * @return {!Array<!HTMLElement>}
   */
  function splitText(el, key, splitOn, includePrevious, preserveWhitespace) {
    // Combine any strange text nodes or empty whitespace.
    el.normalize();

    // Use fragment to prevent unnecessary DOM thrashing.
    var elements = [];
    var F = document.createDocumentFragment();
    if (includePrevious) {
      elements.push(el.previousSibling);
    }
    var allElements = [];
    $(el.childNodes).some(function (next) {
      if (next.tagName && !next.hasChildNodes()) {
        // keep elements without child nodes (no text and no children)
        allElements.push(next);
        return;
      }
      // Recursively run through child nodes
      if (next.childNodes && next.childNodes.length) {
        allElements.push(next);
        elements.push.apply(elements, splitText(next, key, splitOn, includePrevious, preserveWhitespace));
        return;
      }

      // Get the text to split, trimming out the whitespace
      /** @type {string} */
      var wholeText = next.wholeText || '';
      var contents = wholeText.trim();

      // If there's no text left after trimming whitespace, continue the loop
      if (contents.length) {
        // insert leading space if there was one
        if (wholeText[0] === ' ') {
          allElements.push(createText(' '));
        }
        // Concatenate the split text children back into the full array
        each(contents.split(splitOn), function (splitText, i) {
          if (i && preserveWhitespace) {
            allElements.push(createElement(F, "whitespace", " ", preserveWhitespace));
          }
          var splitEl = createElement(F, key, splitText);
          elements.push(splitEl);
          allElements.push(splitEl);
        });
        // insert trailing space if there was one
        if (wholeText[wholeText.length - 1] === ' ') {
          allElements.push(createText(' '));
        }
      }
    });
    each(allElements, function (el) {
      appendChild(F, el);
    });

    // Clear out the existing element
    el.innerHTML = "";
    appendChild(el, F);
    return elements;
  }

  /** an empty value */
  var _ = 0;
  function copy(dest, src) {
    for (var k in src) {
      dest[k] = src[k];
    }
    return dest;
  }
  var WORDS = 'words';
  var wordPlugin = createPlugin( /* by= */WORDS, /* depends= */_, /* key= */'word', /* split= */function (el) {
    return splitText(el, 'word', /\s+/, 0, 1);
  });
  var CHARS = "chars";
  var charPlugin = createPlugin( /* by= */CHARS, /* depends= */[WORDS], /* key= */"char", /* split= */function (el, options, ctx) {
    var results = [];
    each(ctx[WORDS], function (word, i) {
      results.push.apply(results, splitText(word, "char", "", options.whitespace && i));
    });
    return results;
  });

  /**
   * # Splitting
   * 
   * @param {import('./types').ISplittingOptions} opts
   * @return {!Array<*>}
   */
  function Splitting(opts) {
    opts = opts || {};
    var key = opts.key;
    return $(opts.target || '[data-splitting]').map(function (el) {
      var ctx = el['🍌'];
      if (!opts.force && ctx) {
        return ctx;
      }
      ctx = el['🍌'] = {
        el: el
      };
      var by = opts.by || getData(el, 'splitting');
      if (!by || by == 'true') {
        by = CHARS;
      }
      var items = resolve(by);
      var opts2 = copy({}, opts);
      each(items, function (plugin) {
        if (plugin.split) {
          var pluginBy = plugin.by;
          var key2 = (key ? '-' + key : '') + plugin.key;
          var results = plugin.split(el, opts2, ctx);
          key2 && index(el, key2, results);
          ctx[pluginBy] = results;
          el.classList.add(pluginBy);
        }
      });
      el.classList.add('splitting');
      return ctx;
    });
  }

  /**
   * # Splitting.html
   * 
   * @param {import('./types').ISplittingOptions} opts
   */
  function html(opts) {
    opts = opts || {};
    var parent = opts.target = createElement();
    parent.innerHTML = opts.content;
    Splitting(opts);
    return parent.outerHTML;
  }
  Splitting.html = html;
  Splitting.add = add;

  /**
   * Detects the grid by measuring which elements align to a side of it.
   * @param {!HTMLElement} el 
   * @param {import('../core/types').ISplittingOptions} options
   * @param {*} side 
   */
  function detectGrid(el, options, side) {
    var items = $(options.matching || el.children, el);
    var c = {};
    each(items, function (w) {
      var val = Math.round(w[side]);
      (c[val] || (c[val] = [])).push(w);
    });
    return Object.keys(c).map(Number).sort(byNumber).map(selectFrom(c));
  }

  /**
   * Sorting function for numbers.
   * @param {number} a 
   * @param {number} b
   * @return {number} 
   */
  function byNumber(a, b) {
    return a - b;
  }
  var linePlugin = createPlugin( /* by= */'lines', /* depends= */[WORDS], /* key= */'line', /* split= */function (el, options, ctx) {
    return detectGrid(el, {
      matching: ctx[WORDS]
    }, 'offsetTop');
  });
  var itemPlugin = createPlugin( /* by= */'items', /* depends= */_, /* key= */'item', /* split= */function (el, options) {
    return $(options.matching || el.children, el);
  });
  var rowPlugin = createPlugin( /* by= */'rows', /* depends= */_, /* key= */'row', /* split= */function (el, options) {
    return detectGrid(el, options, "offsetTop");
  });
  var columnPlugin = createPlugin( /* by= */'cols', /* depends= */_, /* key= */"col", /* split= */function (el, options) {
    return detectGrid(el, options, "offsetLeft");
  });
  var gridPlugin = createPlugin( /* by= */'grid', /* depends= */['rows', 'cols']);
  var LAYOUT = "layout";
  var layoutPlugin = createPlugin( /* by= */LAYOUT, /* depends= */_, /* key= */_, /* split= */function (el, opts) {
    // detect and set options
    var rows = opts.rows = +(opts.rows || getData(el, 'rows') || 1);
    var columns = opts.columns = +(opts.columns || getData(el, 'columns') || 1);

    // Seek out the first <img> if the value is true 
    opts.image = opts.image || getData(el, 'image') || el.currentSrc || el.src;
    if (opts.image) {
      var img = $("img", el)[0];
      opts.image = img && (img.currentSrc || img.src);
    }

    // add optional image to background
    if (opts.image) {
      setProperty(el, "background-image", "url(" + opts.image + ")");
    }
    var totalCells = rows * columns;
    var elements = [];
    var container = createElement(_, "cell-grid");
    while (totalCells--) {
      // Create a span
      var cell = createElement(container, "cell");
      createElement(cell, "cell-inner");
      elements.push(cell);
    }

    // Append elements back into the parent
    appendChild(el, container);
    return elements;
  });
  var cellRowPlugin = createPlugin( /* by= */"cellRows", /* depends= */[LAYOUT], /* key= */"row", /* split= */function (el, opts, ctx) {
    var rowCount = opts.rows;
    var result = Array2D(rowCount);
    each(ctx[LAYOUT], function (cell, i, src) {
      result[Math.floor(i / (src.length / rowCount))].push(cell);
    });
    return result;
  });
  var cellColumnPlugin = createPlugin( /* by= */"cellColumns", /* depends= */[LAYOUT], /* key= */"col", /* split= */function (el, opts, ctx) {
    var columnCount = opts.columns;
    var result = Array2D(columnCount);
    each(ctx[LAYOUT], function (cell, i) {
      result[i % columnCount].push(cell);
    });
    return result;
  });
  var cellPlugin = createPlugin( /* by= */"cells", /* depends= */['cellRows', 'cellColumns'], /* key= */"cell", /* split= */function (el, opt, ctx) {
    // re-index the layout as the cells
    return ctx[LAYOUT];
  });

  // install plugins
  // word/char plugins
  add(wordPlugin);
  add(charPlugin);
  add(linePlugin);
  // grid plugins
  add(itemPlugin);
  add(rowPlugin);
  add(columnPlugin);
  add(gridPlugin);
  // cell-layout plugins
  add(layoutPlugin);
  add(cellRowPlugin);
  add(cellColumnPlugin);
  add(cellPlugin);
  return Splitting;
});

},{}]},{},[1])


//# sourceMappingURL=main.min.js.map
